{
  "Home": "主页",
  "Download": "下载",
  "Start": "入门",
  "Reference": "参考文献",
  "reference-tagline": "Processing 的直觉乘以 JavaScript 的力量",
  "reference-search": "搜寻 API",
  "reference-menu-home": "主页",
  "reference-menu-download": "下载",
  "reference-menu-get-started": "入门",
  "reference-menu-reference": "参考文献",
  "reference-menu-libraries": "程式库",
  "reference-menu-learn": "学习",
  "reference-menu-examples": "范例",
  "reference-menu-books": "书籍",
  "reference-menu-community": "社群",
  "reference-menu-forum": "论坛",
  "reference-description1": "找不到您要的条目吗？您或许要查看",
  "reference-description2": "或",
  "reference-description3": "You can download an offline version of the reference",
  "reference-description4": "here",
  "reference-contribute1": "发现任何错误或有任何建议吗",
  "reference-contribute2": "请让我们知道",
  "reference-error1": "发现错字或错误吗？",
  "reference-error2": "的文献被记录在",
  "reference-error3": "非常欢迎您",
  "reference-error4": "更改该文件",
  "reference-error5": "并开启一个 pull request。",
  "reference-example": "范例",
  "reference-description": "说明",
  "reference-extends": "继承",
  "reference-parameters": "参数",
  "reference-syntax": "语法",
  "reference-returns": "返回",
  "footer1": "p5.js 的原作者为",
  "footer2": "并在",
  "footer3": "和",
  "footer4": "的支持下由其合作社群所开发。形象及平面设计",
  "Libraries": "程式库",
  "Learn": "学习",
  "Examples": "范例",
  "Books": "书籍",
  "Community": "社群",
  "Contribute": "贡献",
  "Forum": "论坛",
  "h1": "参考文献",
  "Color": "颜色",
  "Shape": "形状",
  "Creating & Reading": "创造及读取",
  "Setting": "设置",
  "2D Primitives": "2D 形状",
  "Attributes": "属性",
  "Curves": "弧形",
  "Vertex": "顶点",
  "3D Models": "3D 模型",
  "3D Primitives": "3D 形状",
  "Constants": "常量",
  "Structure": "结构",
  "Environment": "环境",
  "DOM": "DOM",
  "Rendering": "渲染",
  "Transform": "变形",
  "Data": "资料",
  "Dictionary": "字典",
  "Array Functions": "数组函数",
  "Conversion": "转换",
  "String Functions": "字符串函数",
  "Events": "事件",
  "Acceleration": "加速度",
  "Keyboard": "键盘",
  "Mouse": "滑鼠",
  "Touch": "触动",
  "Image": "图像",
  "Loading & Displaying": "加载和显示",
  "Pixels": "像素",
  "IO": "输入和输出",
  "Input": "输入",
  "Output": "输出",
  "Table": "表格",
  "Time & Date": "时间和日期",
  "XML": "XML",
  "Math": "数学",
  "Calculation": "计算",
  "Noise": "噪声",
  "Trigonometry": "三角学",
  "Typography": "字体",
  "Font": "字形",
  "Lights, Camera": "灯光、相机",
  "Camera": "相机",
  "Lights": "灯光",
  "Material": "材料",
  "p5": {
    "alpha": {
      "description": "从颜色或像素数组中提取透明度（alpha）值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该透明度值"
    },
    "blue": {
      "description": "从颜色或像素数组中提取蓝色彩值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该蓝色彩值"
    },
    "brightness": {
      "description": "从颜色或像素数组中提取 HSB 的亮度值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该亮度值"
    },
    "color": {
      "description": "创造颜色物件并将其存放在颜色变量内。依当时的颜色模式而定，参数可被解读成 RGB 或 HSB 值。默认模式为 RGB 值从 0 至 255，因此调用函数 color(255, 204, 0) 将返回亮黄色。<br><br>请注意如果 color() 值被提供一个参数，它将被解读成灰阶值；增加多一个参数，它将被用来定义透明度。当被提供三个参数时，它们将被解读成 RGB 或 HSB 值；增加第四个参数将定义透明度。<br><br>如果只提供单一字符串参数，RGB、RGBA 和 十六进制 CSS 颜色字符串都为受支持的模式。在这情况下，提供第二个参数以定义透明度值并不被支持，而需使用 RGBA 字符串。",
      "params": ["数字：一个定义白与黑之间的数值",
                 "数字：透明度值，需在被定义的范围内（默认为 0 至 255）",
                 "数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "字符串：颜色字符串",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color："],
      "returns": "p5.Color：返回的颜色"
    },
    "green": {
      "description": "从颜色或像素数组中提取绿色彩值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该绿色彩值"
    },
    "hue": {
      "description": "从颜色或像素数组中提取色调值。<br><br>色调值可在 HSB 及 HSL 颜色中找到。此函数会返回标准化 HSB 值的色调值只要被提供的参数是 HSB 颜色物件（或如果被提供的参数是像素数组，颜色模式是 HSB），不然默认将会返回标准化 HSL 值的色调值。（两者的值只有在这两个不同的系统有不同的最高色调值时才会有差别）",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该色调值"
    },
    "lerpColor": {
      "description": "混合两个颜色以找到一个介于它们之间的颜色。<br><br>amt 参数代表两个值之间插入的量，0.0 代表第一个颜色、0.1 代表非常接近第一个颜色、0.5 代表两个颜色之间的一半等等。低于 0 的值将被当作 0 看待。这和 lerp() 的行为不一样不过这是因为在范围外的值可能产生奇怪和意料之外的颜色。",
      "params": ["p5.Color：从这颜色开始插入",
                 "p5.Color：在这颜色结束插入",
                 "数字：一个介于 0 和 1 的数字"],
      "returns": "p5.Color：插值颜色"
    },
    "lightness": {
      "description": "从颜色或像素数组中提取 HSL 的光度值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该光度值"
    },
    "red": {
      "description": "从颜色或像素数组中提取红色彩值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该红色彩值"
    },
    "saturation": {
      "description": "从颜色或像素数组中提取饱和度值。<br><br>饱和度在 HSB 和 HSL 模式中的缩放比例不同。此函数将会返回 HSB 值的饱和度值只要被提供的参数是 HSB 颜色物件（或如果被提供的参数是像素数组，颜色模式是 HSB），不然默认将会返回 HSL 值的饱和度值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该饱和度值"
    },
    "background": {
      "description": "background() 函数设定 p5.js 画布的背景颜色。默认背景颜色为浅灰色。这函数通常用在 draw() 函数内以在各画面开始时清空画布，不过它也能在 setup() 内使用以定义第一个画面的背景颜色或当背景颜色只需要被定义一次时。<br><br>背景颜色可用 RGB、HSB 或 HSL 颜色定义，取决于当时的颜色模式（默认色彩空间是 RGB，而每个数值都介于 0 至 255 之间）。默认透明度值也介于 0 至 255 之间。<br><br>如果所提供的参数是单一字符串，RGB、RGBA 和十六进制 CSS 颜色字符串及所有命名颜色都可以使用。在这情况下，提供第二个参数以定义透明度值并不被支持，而需使用 RGBA 字符串。<br><br>p5.Color 物件也能被用来定义背景颜色。<br><br>p5.Image 也能被用来提供背景图像。",
      "params": ["p5.Color：任何使用 color() 函数创造的颜色",
               "字符串：颜色字符串，可接受的格式包括：整数 rgb() 或 rgba()、百分率 rgb() 或 rgba()、3 位十六进制、6 位十六进制",
               "数字：透明度值，需在被定义的范围内（默认为 0 至 255）",
               "数字：一个定义白与黑之间的数值",
               "数字：红彩值或色调值（取决于当时的颜色模式）",
               "数字：绿彩值或饱和度值（取决于当时的颜色模式）",
               "数字：蓝彩值或亮度值（取决于当时的颜色模式）",
               "数字[]：一个有红、绿、蓝及透明度值的数组",
               "p5.Image：一个使用 loadImage() 或 createImage() 创造的图像，用以设定背景图像（必须和画布有相同的大小）"],
      "returns": ""
    },
    "clear": {
      "description": "清除图形缓冲区内的像素。这函数只能用于使用 createCanvas() 函数创造的 p5.Canvas 物件，而不能用于主要的显示窗口。使用 createGraphics() 创造的图形缓冲并不像主要的图形缓冲，它们能是完全透明或半透明的。这函数将清空所有东西使每个像素都是 100% 透明。",
      "returns": ""
    },
    "colorMode": {
      "description": "colorMode() 改变 p5.js 解读颜色资料的方式。默认情况下，fill()、stroke()、background() 及 color() 的参数都是介于 0 至 255 的 RGB 颜色值。这和设置 colorMode(RGB, 255) 的效果一样。设置 colorMode(HSB) 让您使用 HSB 模式，默认情况下，这代表 colorMode(HSB, 360, 100, 100, 1)。您也可以使用 HSL。",
      "params": ["常量: RGB、HSB 或 HSL，分别代表红绿蓝及色调/饱和度/亮度（或光度）",
                 "数字：所有数值的最大值",
                 "数字：红色值或色调值的最大值，取决于当时的颜色模式",
                 "数字：绿色值或饱和度值的最大值，取决于当时的颜色模式",
                 "数字：蓝色值或亮度/光度值的最大值，取决于当时的颜色模式",
                 "数字：透明度值的最大值"],
                 "returns": ""
    },
    "fill": {
      "description": "设置形状的填充色。比如说，如果您调用 fill(204, 102, 0)，所有接下来的形状都会被填上橙色。这颜色可用 RGB 或 HSB 颜色定义，取决于当时的颜色模式（默认色彩空间是 RGB，而每个数值都介于 0 至 255 之间）。默认透明度值也介于 0 至 255 之间。<br><br>如果所提供的参数是单一字符串，RGB、RGBA 和十六进制 CSS 颜色字符串及所有命名颜色都可以使用。在这情况下，提供第二个参数以定义透明度值并不被支持，而需使用 RGBA 字符串。<br><br>p5.Color 物件也能被用来定义填充颜色。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "数字：",
                 "字符串：颜色字符串",
                 "数字：灰阶值",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color：填充色"],
      "returns": ""
    },
    "noFill": {
      "description": "禁用形状填充。如果 noStroke() 和 noFill() 都被调用的话，没有形状会被画在荧幕上。",
      "returns": ""
    },
    "noStroke": {
      "description": "禁用形状外线。如果 noStroke() 和 noFill() 都被调用的话，没有形状会被画在荧幕上。",
      "returns": ""
    },
    "stroke": {
      "description": "设置形状的外形线色。这颜色可用 RGB 或 HSB 颜色定义，取决于当时的颜色模式（默认色彩空间是 RGB，而每个数值都介于 0 至 255 之间）。默认透明度值也介于 0 至 255 之间。<br><br>如果所提供的参数是单一字符串，RGB、RGBA 和十六进制 CSS 颜色字符串及所有命名颜色都可以使用。在这情况下，提供第二个参数以定义透明度值并不被支持，而需使用 RGBA 字符串。<br><br>p5.Color 物件也能被用来定义外形线颜色。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "数字：",
                 "字符串：颜色字符串",
                 "数字：灰阶值",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color：外形线色"],
      "returns": ""
    },

    "arc": {
      "description": "在荧幕上画个弧形。如果函数调用只提供 x、y、w、h、start 及 stop 参数，弧形将会被画成开放的饼形段。如果提供 mode 参数，弧形可是开放式半圆形（OPEN）、封闭式半圆形（CHORD）或封闭式饼形段（PIE）。原点可使用 ellipseMode() 函数设定。",
      "params": ["数字：弧形的椭圆形的 x 坐标",
                 "数字：弧形的椭圆形的 y 坐标",
                 "数字：弧形的椭圆形的宽度",
                 "数字：弧形的椭圆形的高度",
                 "数字：弧形开始的角度，用弧度定义",
                 "数字：弧形结束的角度，用弧度定义",
                 "常数：可选参数用以定义弧形的画法，可用 CHORD、PIE 或 OPEN"],
      "returns": ""
    },
    "ellipse": {
      "description": "在荧幕上画个椭圆形。宽度和高度相同的椭圆形为正圆形。在默认上，前两个参数将定义位置而第三和第四个参数将定义形状的宽度和高度。如果高度参数没有被提供的话，宽度参数值将为用来定义高度和宽度。如果高度或宽度为负数，函数将会取绝对值。原点可使用 ellipseMode() 函数设定。",
      "params": ["数字：椭圆形的 x 坐标",
                 "数字：椭圆形的 y 坐标",
                 "数字：椭圆形的宽度",
                 "数字：椭圆形的高度",
                 "整数：椭圆形的径向扇区数"],
      "returns": ""
    },
    "line": {
      "description": "在荧幕上画个直线（两点之间的直接路径）。有四个参数的 line() 函数将画个二维直线。如果要将直线上色，可使用 stroke() 函数。直线并不能有填充色，因此 fill() 函数将不会影响直线的颜色。二维直线在默认情况下有一像素的宽度，不过您可以使用 strokeWeight() 函数更改宽度。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第一个点的 z 坐标",
                 "数字：第二个点的 z 坐标"],
      "returns": ""
    },
    "point": {
      "description": "画一个点，一个在空间内一像素的坐标。第一个参数是点的横向值，第二个参数是点的垂直值。点的颜色是由当时的外线色决定。",
      "params": ["数字：x 坐标",
                 "数字：y 坐标",
                 "数字：z 坐标（用于 WEBGL 模式"],
      "returns": ""
    },
    "quad": {
      "description": "画一个四角形。四角形或四边形是个有四个边的多边形。他和方形相似不过四个角并不需要是九十度。前两个参数 （x1、x2）定义第一个点而随后的配对参数应该以顺时或逆时针的方向定义。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第三个点的 x 坐标",
                 "数字：第三个点的 y 坐标",
                 "数字：第四个点的 x 坐标",
                 "数字：第四个点的 y 坐标",
                 "数字：",
                 "数字：",
                 "数字：",
                 "数字："],
      "returns": ""
    },
    "rect": {
      "description": "在荧幕上画个方形。方形是每个角都为九十度的四边形。在默认上，前两个参数将定义位置而第三和第四个参数将定义形状的宽度和高度。这些参数被解读的方式可用 rectMode() 函数改变。<br><br>如果提供第五、六、七及八个参数，将定义左上角、右上角、右下角及左下角的拐角半径。没被定义的拐角半径参数将被定义为参数列内上一个定义的拐角半径值。",
      "params": ["数字：方形的 x 坐标",
                 "数字：方形的 y 坐标",
                 "数字：方形的宽度",
                 "数字：方形的高度",
                 "数字：可选性左上角拐角半径值",
                 "数字：可选性右上角拐角半径值",
                 "数字：可选性右下角拐角半径值",
                 "数字：可选性左下角拐角半径值",
                 "整数：x 方向段数",
                 "整数：y 方向段数"],
      "returns": ""
    },
    "triangle": {
      "description": "三角形是个由连接三个点所形成的平面形。前两个参数定义第一个点，中间两个参数定义第二个点而最后两个参数定义第三个点。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第三个点的 x 坐标",
                 "数字：第三个点的 y 坐标"],
      "returns": ""
    },
    "ellipseMode": {
      "description": "更改 ellipse() 参数被解读的方式，用以更改椭圆形被画在画布上的位置。<br><br>默认模式为 ellipseMode(CENTER)，ellipse() 前两个参数将被解读成椭圆形的中心点，而第三和第四个参数为宽度和高度。<br><br>ellipseMode(RADIUS) 将 ellipse() 的前两个参数解读成形状的中心点，但是第三和第四个参数被用于定义形状的半径宽度和半径高度<br><br>ellipseMode(CORNER) 将 ellipse() 的前两个参数解读成形状左上角的位置，而第三和第四个参数为宽度和高度<br><br>ellipseMode(CORNERS) 将 ellipse() 的前两个参数解读成形状其中一个角落的位置，而第三和第四个参数则被解读成对面角落的位置。<br><br>参数必须全是大写因为 Javascript 是个区分大小写的编程语言。",
      "params": ["常量：CENTER、RADIUS、CORNER 或 CORNERS"],
      "returns": ""
    },
    "noSmooth": {
      "description": "所有形状的边缘都为锯齿状。注意 smooth() 为默认模式所以您必须调用 noSmooth() 以禁用平滑形状、图像及字体。",
      "returns": ""
    },
    "rectMode": {
      "description": "更改 rect() 参数被解读的方式，用以更改方形被画在画布上的位置。<br><br>默认模式为 rectMode(CORNER), rect() 前两个参数将被解读成形状的左上角的位置，而第三和第四个参数为宽度和高度。<br><br>rectMode(CORNERS) 将 rect() 的前两个参数解读成形状其中一个角落的位置，而第三和第四个参数则被解读成对面角落的位置。<br><br>rectMode(CENTER) 将 rect() 的前两个参数解读成形状的中心点，而第三和第四个参数为宽度和高度。<br><br>rectMode(RADIUS) 也将的前两个参数解读成形状的中心点，但第三和第四个参数被用来定义形状一半的宽度和一半的高度。<br><br>参数必须全是大写因为 Javascript 是个区分大小写的编程语言。",
      "params": ["常量：CORNER、CORNERS、CENTER 或 RADIUS"],
      "returns": ""
    },
    "smooth": {
      "description": "所有形状的边缘都为非锯齿（平滑）状。smooth() 也将提高调整过大小的图像的素质。注意 smooth() 为默认模式；noSmooth() 也能用来禁用平滑形状、图像及字体。",
      "returns": ""
    },
    "strokeCap": {
      "description": "定义线条顶点的风格。顶点风格可以是方形、扩展式或圆形，它们个别参数为：SQUARE、PROJECT 及 ROUND。默认模式为 ROUND。",
      "params": ["常量：SQUARE、PROJECT 或 ROUND"],
      "returns": ""
    },
    "strokeJoin": {
      "description": "定义线条连接的风格。这些链接可以是尖角、斜角或圆角，它们个别参数为：MITER、BEVEL 及 ROUND。默认模式为 MITER。",
      "params": ["常量：MITER、BEVEL 或 ROUND"],
      "returns": ""
    },
    "strokeWeight": {
      "description": "定义线条、点及形状边线的宽度（粗度）。所有宽度单位都是像素。",
      "params": ["数字：线条的粗度（像素单位）"],
      "returns": ""
    },
    "bezier": {
      "description": "在荧幕上画个三次贝塞尔曲线。这些曲线是由一系列锚点和控制点所定义的。前两个参数定义第一个锚点而最后两个参数定义另一个锚点，这也是曲线的第一和最后一个点。中间的参数是用来定义控制点的位置并将决定曲线的形状。一般来说，控制点会将曲线“拉”向它们的方向。",
      "params": ["数字：第一个锚点的 x 坐标",
                 "数字：第一个锚点的 y 坐标",
                 "数字：第一个控制点的 x 坐标",
                 "数字：第一个控制点的 y 坐标",
                 "数字：第二个控制点的 x 坐标",
                 "数字：第二个控制点的 y 坐标",
                 "数字：第二个锚点的 x 坐标",
                 "数字：第二个锚点的 y 坐标",
                 "数字：第一个锚点的 z 坐标",
                 "数字：第一个控制点的 z 坐标",
                 "数字：第二个锚点的 z 坐标",
                 "数字：第二个控制点的 z 坐标"],
      "returns": ""
    },
    "bezierDetail": {
      "description": "定义贝塞尔曲线的解析度<br><br>默认值为 20。<br><br>这函数只有在 WEBGL 模式下有效果因为默认画布渲染模式并不会使用这设定。",
      "params": ["数字：曲线的解析度"],
      "returns": ""
    },
    "bezierPoint": {
      "description": "计算在 a、b、c、d 点定义的贝塞尔曲线上 t 位置的坐标。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。这函数可以先调用 x 坐标然后在调用 y 坐标已找到曲线上 t 位置的点坐标。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的值"
    },
    "bezierTangent": {
      "description": "计算在 a、b、c、d 点定义的贝塞尔曲线上 t 位置的切线值。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的切线值"
    },
    "curve": {
      "description": "在荧幕上的两点之间画一个曲线，两点由中间四个参数定义。前两个参数为控制点，可以当作曲线是从这个点开始的虽然它并不会被画出来。最后两个参数同样也是用来定义另外一个控制点。<br><br>更长的曲线能使用一系列 curve() 函数创造或使用 curveVertex()。另外一个叫 curveTightness() 的函数提供曲线视觉质量的控制。curve() 函数使用的是 Catmull-Rom 样条函数。",
      "params": ["数字：起点控制点的 x 坐标",
                 "数字：起点控制点的 y 坐标",
                 "数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：终点控制点的 x 坐标",
                 "数字：终点控制点的 y 坐标",
                 "数字：起点控制点的 z 坐标",
                 "数字：第一个点的 z 坐标",
                 "数字：第二个点的 z 坐标",
                 "数字：终点控制点的 z 坐标"],
      "returns": ""
    },
    "curveDetail": {
      "description": "定义曲线的解析度<br><br>默认值为 20。<br><br>这函数只有在 WEBGL 模式下有效果因为默认画布渲染模式并不会使用这设定。",
      "params": ["数字：曲线的解析度"],
      "returns": ""
    },
    "curveTightness": {
      "description": "更改由 curve() 及 curveVertex() 所创造的曲线的质量。所提供的参数将决定曲线如何切合顶点。0.0 是紧实度的默认值（这值表示曲线为 Catmull-Rom 样条）而 1.0 将使用直线连接所有点。在 -5.0 及 5.0 之间的值会是曲线变形不过他们仍然能被识别而当值越来越大时，曲线也会跟着变形。",
      "params": ["数字：从原顶点的变形量"],
      "returns": ""
    },
    "curvePoint": {
      "description": "计算在 a、b、c、d 点定义的曲线上 t 位置的坐标。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。这函数可以先调用 x 坐标然后在调用 y 坐标已找到曲线上 t 位置的点坐标。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的值"
    },
    "curveTangent": {
      "description": "计算在 a、b、c、d 点定义的曲线上 t 位置的切线值。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的切线值"
    },
    "beginContour": {
      "description": "使用 beginContour() 及 endContour() 函数以在其他形状内创造剪影形状，比如说 “O” 字母内的空间。beginContour() 将开始记录形状的顶点而 endContour() 则停止记录。定义剪影形状的顶点定义的方向（顺时或逆时针）必须和包含它的形状不同。如果外形的顶点是顺时针方向定义的，那么它里面的形状的顶点需是逆时针方向定义。<br><br>这些函数只能在一对 beginShape()/endShape() 函数之间使用而变形函数如 translate()、rotate() 及 scale() 在一对 beginContour()/endContour() 内并不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在里面使用。",
      "returns": ""
    },
    "beginShape": {
      "description": "使用 beginShape() 及 endShape() 函数可让您创造更复杂的形状。beginShape() 将开始记录形状的顶点而 endShape() 则停止记录。所提供的参数将决定由所提供的顶点该画出怎样的形状。如果模式没有被提供，所定义的形状可以是任何不规则的多边形。<br><br>可提供给 beginShape() 的参数包括 POINTS、LINES、TRIANGLES、TRIANGLE_FAN、TRIANGLE_STRIP、QUADS 及 QUAD_STRIP。在调用 beginShape() 函数之后，一系列 vertex() 函数必须接着调用。调用 endShape() 以停止绘制形状。每个形状都将会有由当时外线色所定义的外线色及当时的填充色。<br><br>变形函数如 translate()、rotate() 及 scale() 在 beginShape() 内不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在beginShape()里面使用。",
      "params": ["常量：POINTS、LINES、TRIANGLES、TRIANGLE_FAN、TRIANGLE_STRIP、QUADS 或 QUAD_STRIP"],
      "returns": ""
    },
    "bezierVertex": {
      "description": "定义贝塞尔曲线的顶点坐标。每次调用 bezierVertex() 将定义贝塞尔曲线的两个控制点和一个锚点，以在线或形状上增加一个新部分。<br><br>在 beginShape() 内第一次调用 bezierVertex() 之前必须先调用一次 vertex() 以定义第一个锚点。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。",
      "params": ["数字：第一个控制点的 x 坐标",
                 "数字：第一个控制点的 y 坐标",
                 "数字：第二个控制点的 x 坐标",
                 "数字：第二个控制点的 y 坐标",
                 "数字：第一个锚点的 x 坐标",
                 "数字：第二个锚点的 x 坐标"],
      "returns": ""
    },
    "curveVertex": {
      "description": "定义曲线顶点的坐标。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。<br><br>在一系列 curveVertex() 线条中第一个和最后一个点将被用来引导曲线的起点和终点。至少必须提供四个点以画一个介于第二和第三个点的小曲线。增加第五个点将会在第二、第三及第四个点之间画个曲线。curveVertex() 函数使用的是 Catmull-Rom 样条函数。",
      "params": ["数字：顶点的 x 坐标",
                 "数字：顶点的 y 坐标"],
      "returns": ""
    },
    "endContour": {
      "description": "使用 beginContour() 及 endContour() 函数以在其他形状内创造剪影形状，比如说 “O” 字母内的空间。beginContour() 将开始记录形状的顶点而 endContour() 则停止记录。定义剪影形状的顶点定义的方向（顺时或逆时针）必须和包含它的形状不同。如果外形的顶点是顺时针方向定义的，那么它里面的形状的顶点需是逆时针方向定义。<br><br>这些函数只能在一对 beginShape()/endShape() 函数之间使用而变形函数如 translate()、rotate() 及 scale() 在一对 beginContour()/endContour() 内并不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在里面使用。",
      "returns": ""
    },
    "endShape": {
      "description": "endShape() 函数和 beginShape() 是一对的而且它只能在 beginShape() 后使用。当 endshape() 被调用时，自上一次 beginShape() 调用后的所有被定义的图像资料将被写进图像缓冲区。定义常量 CLOSE 给 MODE 参数将会关闭该形状（连接起点和终点）。",
      "params": ["常量：使用 CLOSE 以关闭形状"],
      "returns": ""
    },
    "quadraticVertex": {
      "description": "定义二次贝塞尔曲线顶点的坐标。每次调用 quadraticVertex() 将定义贝塞尔曲线的一个控制点和一个锚点，以在线或形状上增加一个新部分。在 beginShape() 内第一次调用 quadraticVertex() 之前必须先调用一次 vertex() 以定义第一个锚点。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。",
      "params": ["数字：控制点的 x 坐标",
                 "数字：控制点的 y 坐标",
                 "数字：锚点的 x 坐标",
                 "数字：锚点的 y 坐标"],
      "returns": ""
    },
    "vertex": {
      "description": "所有形状都是由连接一系列顶点形成的。vertex() 可用于定义点、线、三角形、四角形及多边形的顶点坐标。它只能在 beginShape() 和 endShape() 函数之间使用。",
      "params": ["数字：顶点的 x 坐标",
                 "数字：顶点的 y 坐标",
                 "数字：顶点的 z 坐标",
                 "数字：顶点的纹理 u 坐标",
                 "数字：顶点的纹理 v 坐标"],
      "returns": ""
    },
    "loadModel": {
      "description": "从一个 OBJ 档案加载一个三维模型。<br><br>OBJ 格式的其中一个限制是它没有内建的大小值。这表示不同程式输出的模型可能有非常不同的大小。如果您的模型没被展示的话，请试着调用 loadModel() 并给予 normalized 参数“真”（true）值。这会将模型缩放成适合 p5 的大小。您也可以使用 scale() 函数对您的模型最后大小做与更多的调整。",
      "params": ["字符串：要加载的模型的路径",
                 "布尔值：如果为真，在加载时将模型缩放成标准大小。",
                 "函数(p5.Geometry)：此函数将在模型完成加载后被调用，将被给予该三维模型为参数。",
                 "函数(Event)：如果模型加载失败，此函数将被调用并给予错误事件（event）为参数。"],
      "returns": "p5.Geometry：p5.Geometry 物件"
    },
    "model": {
      "description": "将一个三维模型渲染在荧幕上。",
      "params": ["p5.Geometry：要渲染的已加载的模型"],
      "returns": ""
    },
    "plane": {
      "description": "用给予的宽度和高度画一个平面。",
      "params": ["数字：平面的宽度",
                 "数字：平面的高度",
                 "整数：（可选）在 x 轴的三角形细分数",
                 "整数：（可选）在 y 轴的三角形细分数"],
      "returns": ""
    },
    "box": {
      "description": "用给予的宽度、高度及深度画一个立方体。",
      "params": ["数字：立方体的宽度",
                 "数字：立方体的高度",
                 "数字：立方体的深度",
                 "整数：（可选）在 x 轴的三角形细分数",
                 "整数：（可选）在 y 轴的三角形细分数"],
      "returns": ""
    },
    "sphere": {
      "description": "用给予的半径画一个球形。",
      "params": ["数字：球形的半径",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 16"],
      "returns": ""
    },
    "cylinder": {
      "description": "用给予的半径和高度画一个圆筒形。",
      "params": ["数字：表面的半径",
                 "数字：圆筒形的高度",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：y 轴分割的数量，越多分割几何形越平滑，默认值为 1",
                 "布尔值：是否该画圆筒形的底部",
                 "布尔值：是否该画圆筒形的顶部"],
      "returns": ""
    },
    "cone": {
      "description": "用给予的半径和高度画一个锥体形。",
      "params": ["数字：底部表面的半径",
                 "数字：锥体形的高度",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 1",
                 "布尔值：是否该画锥体形的底部"],
      "returns": ""
    },
    "ellipsoid": {
      "description": "用给予的半径画一个椭球形。",
      "params": ["数字：椭球形 x 轴的半径",
                 "数字：椭球形 y 轴的半径",
                 "数字：椭球形 z 轴的半径",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24。避免多于 150 的细节数量，因为它可能是浏览器停止运作。",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 16。避免多于 150 的细节数量，因为它可能是浏览器停止运作。"],
      "returns": ""
    },
    "torus": {
      "description": "用给予的半径和管半径画一个圆环形。",
      "params": ["数字：整个圆环形的半径",
                 "数字：圆管的半径",
                 "整数：x 轴分割的数量，越多分割几何形越平滑，默认值为 24。",
                 "整数：y 轴分割的数量，越多分割几何形越平滑，默认值为 16。"],
      "returns": ""
    },
    "HALF_PI": {
      "description": "HALF_PI 是个值为 1.57079632679489661923 的数学常量。它是圆形周长与直径的比例的一半。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "PI": {
      "description": "PI 是个值为 3.14159265358979323846 的数学常量。它是圆形周长与直径的比例。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "QUARTER_PI": {
      "description": "QUARTER_PI 是个值为 0.7853982 的数学常量。它是圆形周长与直径的比例的四分之一。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "TAU": {
      "description": "TAU 是 TWO_PI 的别名，是个值为 6.28318530717958647693 的数学常量。它是圆形周长与直径的比例的两倍。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "TWO_PI": {
      "description": "TWO_PI 是个值为 6.28318530717958647693 的数学常量。它是圆形周长与直径的比例的两倍。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "DEGREES": {
      "description": "与 angleMode() 函数一起使用的常量，用于设定 p5.js 如何解读及计算角度（可以是 DEGREES 或 RADIANS）。",
      "returns": ""
    },
    "RADIANS": {
      "description": "与 angleMode() 函数一起使用的常量，用于设定 p5.js 如何解读及计算角度（可以是 DEGREES 或 RADIANS）。",
      "returns": ""
    },
    "preload": {
      "description": "La función preload() es ejecutada antes de setup(), es usada para manejar la carga asíncrona de archivos externos. Si se define una función preload(), setup() esperará hasta que las llamadas a funciones load hayan terminado. Solo se deben incluir instrucciones de carga dentro de preload() (loadImage, loadJSON, loadFont, loadStrings, etc).",
      "returns": "该 p5 物件"
    },
    "setup": {
      "description": "La función setup() es ejecutada una vez, cuando el programa empieza. Es usada para definir propiedades iniciales como amaño de la pantalla y color de fondo y para cargar medios como imágenes y tipografías cuando el programa empieza. Solo puede haber una función setup() en cada programa y no debe ser llamada después de su ejecución inicial. Nota: las variables declaradas dentro de setup() no son accesibles dentro de otras funciones, como draw().",
      "returns": "该 p5 物件"
    },
    "draw": {
      "description": "La función draw() es ejecutada después de setup(), y ejecuta contínuamente las líneas de código dentro de su bloque hasta que el programa es detenido o se ejecuta la función noLoop(). Notar que si noLoop() es ejecutada dentro de setup(), draw() igualmente será ejecutado una vez antes de parar. La función draw() es ejecutada automáticamente y nunca debiera ser ejecutada explícitamente. Siempre debería ser controlada con noLoop(), redraw() y loop(). Después de que noLoop() detiene la ejecución del código dentro de draw(), redraw() causa que el código dentro de draw() se ejecute una vez, y loop() causa que el código dentro de draw() siga ejecutándose de forma continua. El número de veces que draw() se ejecuta por segundo puede ser controlado con la función frameRate(). Solo puede haber una función draw() en cada bosquejo, y draw() solo debe existir si quieres que el código corra de forma continua, o para procesar eventos como mousePressed(). Algunas veces, podrías querer ejecutar una función draw() vacía, como se mostró en el ejemplo más arriba. Es importante notar que el sistema de coordenadas de dibujo será reiniciado al principio de cada ejecución de la función draw(). Si cualquier transformación es hecha dentro de draw() (por ejemplo: escalar, rotar, trasladar), sus efectos serán anulados al principio de cada ejecución de draw(), así que las transformaciones no se acumulan en el tiempo. Por el otro lado, el estilo aplicado (color de relleno, color de trazado) sí se mantendrá en efecto. ",
      "returns": "该 p5 物件"
    },
    "remove": {
      "description": "Remueve el bosquejo de p5 completamente. Esto removerá el lienzo y cualquier otro elemento creado por p5.js. También detendrá el bucle de dibujo y desvinculará cualquier propiedad o método global de la ventana. Dejará una variable p5 en caso que quieras crear un nuevo bosquejo p5. Si quieres, puedes definir p5 = null para borrar esta variable.",
      "returns": "该 p5 物件"
    },
    "noLoop": {
      "description": "Detiene la ejecución continua del código de draw() de p5.js. Si se llama a la función loop(), el código dentro de draw() empieza a correr de forma continua nuevamente. Si se usa noLoop() dentro de setup(), debe ser la última línea de código dentro del bloque. Cuando se usa noLoop(), no es posible manipular o acceder a la pantalla dentro de las funciones que manejan eventos como mousePressed() o keyPressed(). En vez de eso, usa estas funciones para llamar a redraw() o loop(), que permitirán la ejecución de draw(), lo que permite el refresco correcto de la pantalla. Esto significa que cuando noLoop() ha sido ejecutado, no se sigue dibujando, y funciones como saveFrame() o loadPixels() no se pueden usar. Notar que si el bosquejo es escalado, redraw() será llamado para actualizar el bosquejo, incluso si noLoop() ha sido ejecutada. Por otro lado, el bosquejo entrará a un estado singular, hasta que loop() sea ejecutado.",
      "returns": "该 p5 物件"
    },
    "loop": {
      "description": "Por defecto, p5.js repite de forma continua la función draw(), ejecutado el código dentro de su bloque. Sin embargo, el bucle de dibujo puede ser detenido llamando a la función noLoop(). En ese caso, el bucle de draw() puede ser retomado con loop().",
      "returns": "该 p5 物件"
    },
    "push": {
      "description": "La función push() graba la configuración actual de estilo de dibujo, y pop() restaura esta configuración. Notar que estas funciones siempre son usadas en conjunto. Permiten cambiar las configuraciones de estilo y transformaciones y luego volver a lo que tenías. Cuando un nuevo estado es iniciado con push(), construye encima de la información actual de estilo y transformación. Las funciones push() y pop() pueden ser embebidas para proveer más control (ver el segundo ejemplo para una demostración). push() almacena información relacionada a la configuración de estado de transformación y de estulo actual, controlada por las siguientes funciones: fill(), stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), colorMode(), textAlign(), textFont(), textMode(), textSize(), textLeading().",
      "returns": "该 p5 物件"
    },
    "pop": {
      "description": "La función push() graba la configuración actual de estilo de dibujo, y pop() restaura esta configuración. Notar que estas funciones siempre son usadas en conjunto. Permiten cambiar las configuraciones de estilo y transformaciones y luego volver a lo que tenías. Cuando un nuevo estado es iniciado con push(), construye encima de la información actual de estilo y transformación. Las funciones push() y pop() pueden ser embebidas para proveer más control (ver el segundo ejemplo para una demostración). push() almacena información relacionada a la configuración de estado de transformación y de estulo actual, controlada por las siguientes funciones: fill(), stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), colorMode(), textAlign(), textFont(), textMode(), textSize(), textLeading()."
    },
    "redraw": {
      "description": "Ejecuta una vez el código dentro de la función draw(). Esta función permite al programa actualizar la ventana mostrada solamente cuando es necesario, por ejemplo, cuando un evento registrado por mousePressed() o keyPressed() ocurre. En la estructura de un programa, solo hace sentido llamar a redraw() dentro de eventos como mousePressed(). Esto es porque redraw() no hace que draw() se ejecute de forma inmediata (solo define una indicación de que se necesita un refresco). La función redraw() no funciona de forma correcta cuando se llama dentro de la función draw(). Para habilitar y deshabilitar animaciones, usa las funcioens loop() y noLoop(). Adicionalmente, puedes definir el número de veces que se dibuja por cada llamada a este método. Para esto, añade un entero como parámetro único a la función, que señale cuántas veces se requiere dibujar.",
      "params": ["Entero: redibuja n-veces. Por defecto el valor es 1"],
      "returns": "该 p5 物件"
    },
    "print": {
      "description": "La función print() escribe en la consola del navegador. Esta función es a menudo de ayuda para observar los datos que un programa está produciendo. Esta función crea una nueva línea de texto por cada ejecución de la función. Elementos individuales pueden ser separados por comillas ('') y unidos con el operador de adición (+). Aunque print() es similar a console.log(), no llama a console.log() directamente, para simular una manera más simple de entender el comportamiento del programa. Por esto mismo, es más lento. Para resultados más rápidos, usar directamente console.log().",
      "params": ["Cualquiera: cualquier combinación de número, string, objeto, boolean o arreglo a imprimir"],
      "returns": "该 p5 物件"
    },
    "frameCount": {
      "description": "La variable de sistema frameCount contiene el número de cuadros (frames) que se han mostrado desde que el programa empezó a ejecutarse. Dentro de setup() el valor es 0, después de la primera iteración de draw() es 1, etc.",
      "returns": "该 p5 物件"
    },
    "focused": {
      "description": "Confirma si la ventana de un programa de p5.js está en foco, lo que significa que el bosquejo aceptará entradas desde el ratón o teclado. Esta variable es verdadera (true) si la ventana está en foco y falsa (false) si no.",
      "returns": "该 p5 物件"
    },
    "cursor": {
      "description" : "Define el cursor como un símbolo predeterminado o una imagen, o hace el cursor visible si es que estaba escondido. Si estás tratando de asignar una imagen al cursor, el tamaño recomendado es 16x16 o 32x32 pixeles. No es posible cargar una imagen al cursor si estás exportando tu programa a la Web, y no todos los modos funcionan con todos los navegadores. Los valores de los parámetros x e y deben ser menores a la dimensión de la imagen.",
      "params": ["Número|Constante: puede ser ARROW, CROSS, HAND, MOVE, TEXT, o WAIT, o la dirección de una imagen",
      "Número: el punto activo horizontal del cursor",
      "Número: el punto activo vertical del cursor"],
      "returns": "该 p5 物件"
    },
    "frameRate": {
      "description": "Especifica el número de cuadros mostrados por segundo. Por ejemplo, la llamada a la función frameRate(30), tratará de refrescar 30 veces por segundo. Si el procesador no es lo suficientemente rápido para mantener la tasa especificada, la tasa de cuadros por segundo no será lograda. Definir la tasa de cuadros por segundo dentro de setup() es lo recomendable. La tasa por defecto es de 60 veces por segundo. Esto es lo mismo que setFrameRate(val). Llamar a la función frameRate() sin argumentos retorna la tasa actual. Esto es lo mismo que getFrameRate(). Llamar a la función frameRate() con arugmentos que no son de tipo número o no son positivos también retornarán la tasa actual.",
      "params": ["Número: número de cuadros a ser mostrados cada segundo."],
      "returns": "la tasa de cuadros por segundo (frameRate) actual"
    },
    "noCursor": {
      "description": "Esconde el cursor.",
      "returns": "该 p5 物件"
    },

    "displayWidth": {
      "description": "Variable de sistema que almacena el ancho de la pantalla mostrada. Esto es usado para correr un programa a pantalla completa en cualquier dimensión de pantalla.",
      "returns": "该 p5 物件"
    },
    "displayHeight": {
      "description": "Variable de sistema que almacena la altura de la pantalla mostrada. Esto es usado para correr un programa a pantalla completa en cualquier dimensión de pantalla.",
      "returns": "该 p5 物件"
    },
    "windowWidth": {
      "description": "Variable de sistema que almacena el ancho interior de la ventana del navegador, equivale a window.innerWidth.",
      "returns": "该 p5 物件"
    },
    "windowHeight": {
      "description": "Variable de sistema que almacena la altura interior de la ventana del navegador, equivale a window.innerHeight.",
      "returns": "该 p5 物件"
    },
    "windowResized": {
      "description": "La función windowResized() es llamada cada vez que la ventana del navegador cambia de tamaño. Es un buen lugar para cambiar las dimensiones del lienzo o hacer cualquier otro ajuste necesario para acomodar las nuevas dimensiones de la ventana.",
      "returns": "该 p5 物件"
    },
    "width": {
      "description": "Variable de sistema que almacena el ancho del lienzo dibujado. Este valor es definido por el primer parámetro de la función createCanvas(). Por ejemplo, la llamada a la función (320, 240) define la variable width al valor 320. El valor por defecto de ancho es de 100 si es que createCanvas() no ha sido usado en el programa.",
      "returns": "该 p5 物件"
    },
    "height": {
      "description": "ariable de sistema que almacena la altura del lienzo dibujado. Este valor es definido por el primer parámetro de la función createCanvas(). Por ejemplo, la llamada a la función (320, 240) define la variable width al valor 240. El valor por defecto de ancho es de 100 si es que createCanvas() no ha sido usado en el programa.",
      "returns": "该 p5 物件"
    },
    "fullscreen": {
      "description": "Si se da un argumento, define que el bosquejo esté a pantalla completa basado en el valor del argumento. Si no se da un argumento, retorna el estado actual de pantalla completa. Notar que debido a restricciones del navegador esto solo puede ser llamado con una entrada de parte del usuario, por ejemplo, cuando se presiona el ratón como en el ejemplo.",
      "params": ["Boolean: define si el bosquejo debe estar a pantalla completa o no."],
      "returns": "Boolean: estado de pantalla completa actual"
    },
    "pixelDensity": {
      "description": "Define el escalamiento de pixeles para monitores de alta densidad de pixeles. Por defecto, la densidad de pixeles es definida para calzar con la densidad del monitor, ejecuta pixelDensity() para que no sea así. Llamar a pixelDensity() sin argumentos retorna la densidad de pixeles actual del bosquejo.",
      "params": ["Número: si es que el bosquejo debe ser escalado y cuánto."],
      "returns": "Número: densidad de pixeles actual del bosquejo"
    },
    "displayDensity": {
      "description": "Retorna la densidad de pixeles del monitor actual en que el bosquejo está corriendo.",
      "returns": "Número: la densidad de pixeles actual del monitor"
    },
    "getURL": {
      "description": "Retorna la URL actual.",
      "returns": "String: URL"
    },
    "getURLPath": {
      "description": "Retorna la dirección URL como un arreglo",
      "returns": "Arreglo: los componentes de la dirección"
    },
    "getURLParams": {
      "description": "Retorna los parámetros de la URL actual como un objeto.",
      "returns": "物件：parámetros de la URL"
    },
    "createCanvas": {
      "description": "Crea un elemento canvas en el documento, y define sus dimensiones medidas en pixeles. Este método debe ser llamado solo una vez al comienzo de la función setup(). Llamar a la función createCanvas() más de una vez en un bosquejo puede resultar en comportamientos impredecibles. Si quieres más de un lienzo donde dibujar, debes usar la función createGraphics() (escondido por defecto, pero puede ser mostrado), Las variables de sistema width (ancho) y height (altura) son definidas por los parámetros pasados a la función. Si createCanvas() no es usado, la ventana tendrá un tamaño por defecto de 100 x 100 pixeles. Para más maneras de posicionar el lienzo, ver la sección de posición del lienzo.",
      "params": ["Número: ancho del lienzo",
      "Número: altura del lienzo",
      "Constante: P2D o WEBGL"],
      "returns": "物件：lienzo generado"
    },
    "resizeCanvas": {
      "description": "Redimensiona el linezo al ancho y la altura dados. El lienzo será borrado y la función draw() será llamada inmediatamente, permitiendo que el bosquejo se ajuste al nuevo lienzo",
      "returns": "该 p5 物件"
    },
    "noCanvas": {
      "description": "Remueve el lienzo por defecto para un bosquejo de p5 que no requiere un lienzo.",
      "returns": "该 p5 物件"
    },
    "createGraphics": {
      "description": "Crea y retorna un nuevo objeto p5.Renderer. Usa esta clase si necesitas dibujar fuera de pantalla en un buffer gráfico. Los dos parámetros definen el ancho y la altura en pixeles.",
      "params": ["Número: ancho del buffer gráfico fuera de pantalla",
      "Número: altura del buffer gráfico fuera de pantalla",
      "Constante: P2D o WEBGL, si no se define es P2D por defecto"],
      "returns": "buffer gráfico fuera de pantalla"
    },
    "blendMode": {
      "description": "Combina los pixeles en la ventana según el modo definido. Existen distintas maneras de combinar los pixeles de la fuente (A) con los ya existentes en la pantalla mostrada (B). TODO",
      "params": ["Constante: modo de combinar del lienzo"],
      "returns": "该 p5 物件"
    },
    "applyMatrix": {
      "description": "Multiplica la matriz actual por la especificada según los parámetros. Esto es muy lento porque tratará de calcular el inverso de la transformada, así que evítalo cuando sea posible",
      "params": ["Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar"],
      "returns": "该 p5 物件"
    },
    "resetMatrix": {
      "description": "Reemplaza la matriz actual con la matriz identidad",
      "returns": "该 p5 物件"
    },
    "rotate": {
      "description": "Rota una figura según el monto especificado por el parámetro ángulo. Esta función toma en cuenta el modo de ángulo definido por angleMode(), así que los ángulos pueden ser ingresados en radianes o grados. Los objetos son siempre rotados según su posición relativa al origen y los números positivos rotan en la dirección de las manecillas del reloj. Las transformaciones se aplican a todo lo que ocurre de forma posterior y las subsecuentes llamadas a la función acumulan el efecto. Por ejemplo, llamar a la función rotate(HALF_PI) y luego rotate(HALF_PI) equivale a una llamada a rotate(PI). Todas las transformaciones son anuladas cuando la función draw() comienza nuevamente. Técnicamente, rotate() multiplica la matriz de transformación actual por una matriz de rotación. Esta función puede ser controlada además con las funciones push() y pop().",
      "params": ["Ángulo: el ángulo de rotación, especificado en radianes o grados, dependiendo de angleMode()",
      "Número: ángulo en radianes",
      "p5.Vector|Arreglo: eje sobre el que se rota"],
      "returns": "该 p5 物件"
    },
    "rotateX": {
      "description": "Rota en torno al eje X",
      "params": ["Número: ángulo en radianes"],
      "returns": "该 p5 物件"
    },
    "rotateY": {
      "description": "Rota en torno al eje Y",
      "params": ["Número: ángulo en radianes"],
      "returns": "该 p5 物件"
    },
    "rotateZ": {
      "description": "Rota en torno al eje Z,. Sólo disponible en el modo WEBGL.",
      "params": ["Número: ángulo en radianes"],
      "returns": "该 p5 物件"
    },
    "scale": {
      "description": "Aumenta o decrementa el tamaño de una figura por medio de expandir o contraer sus vértices. Los objetos siempre escalan desde su origen relativo al sistema de coordenadas. Los valores de escalamiento son porcentajes decimales. Por ejemplo, la llamada a la función scale(2.0) aumenta la dimensión de una figura en un 200%. Las transformaciones se aplican a todo lo que ocurre después y llamadas subsecuentes a la función multiplican el efecto. Por ejemplo, llamar a scale(2.0) y luego a scale(1.5) equivale a llamar a scale(3.0). Si la función scale() es llamad dentro de draw(), la transformación es anulada cuando el bucle empieza nuevamente. El uso de esta función con el parámetro z está solo disponible en el modo WEBGL. Esta función puede también ser controlada con las funciones push() y pop().",
      "params": ["Número | p5.Vector| Arreglo: porcentaje a escalar del objeto, o porcentaje a esacalar del objeto en el eje x si se dan múltiples argumentos",
      "Número: porcentaje a escalar el objeto en el eje y",
      "Número: porcentaje a escalar el objeto en el eje z (sólo en modo WEBGL)"],
      "returns": "该 p5 物件"
    },
    "shearX": {
      "description": "Corta la figura en torno al eje x según el monto especificado por el parámetro ángulo. Los ángulos deben ser especificados según el modo actual de ángulo angleMode(). Los objetos son siempre cortados según su posición relativa al origen y los números positivos cortan los objetos en la dirección de las manecillas del reloj. Las transformaciones aplican a todo lo que ocurre después y llamadas posteriores a la misma función acumulan el efecto. Por ejemplo, llamar a shearX(PI/2) y luego a shearX(PI/2) equivale a llamar a shearX(PI). Si shearX() es llamado dentro de draw(), la transformación es anulada cuando el bucle empieza nuevamente. Técnicamente, shearX() multiplica la matriz de transformación actual por una matriz de rotación. La función puede ser controlada con las funciones push() y pop().",
      "params": ["Número: ángulo de corte especificado en radianes o grados, dependiendo del modo de ángulo actual angleMode()"],
      "returns": "该 p5 物件"
    },
    "shearY": {

        "description": "Corta la figura en torno al eje y según el monto especificado por el parámetro ángulo. Los ángulos deben ser especificados según el modo actual de ángulo angleMode(). Los objetos son siempre cortados según su posición relativa al origen y los números positivos cortan los objetos en la dirección de las manecillas del reloj. Las transformaciones aplican a todo lo que ocurre después y llamadas posteriores a la misma función acumulan el efecto. Por ejemplo, llamar a shearY(PI/2) y luego a shearY(PI/2) equivale a llamar a shearY(PI). Si shearY() es llamado dentro de draw(), la transformación es anulada cuando el bucle empieza nuevamente. Técnicamente, shearY() multiplica la matriz de transformación actual por una matriz de rotación. La función puede ser controlada con las funciones push() y pop().",
        "params": ["Número: ángulo de corte especificado en radianes o grados, dependiendo del modo de ángulo actual angleMode()"],
        "returns": "该 p5 物件"
    },
    "translate": {
      "description": "Especifica una cantidad a desplazar los objetos dentro de la ventana mostrada. El parámetro x especifica la traslación de izquierda a derecha, el parámetro y especifica la traslación de arriba a abajo. Las transformaciones son acumulativas y aplican a todo lo que ocurre después y llamadas posteriores a la misma función acumulan el efecto. Por ejemplo, llamar a translate(50, 0) y luego a translate(20, 0) equivale a llamar a translate(70, 0). Si translate() es llamado dentro de draw(), la transformación es anulada cada vez que el bucle empieza nuevamente. Esta función peude ser controlada con las funciones push() y pop().",
      "params": ["Número: traslación izquierda-derecha",
      "Número: traslación arriba-abajo",
      "Número: traslación adelante-atrás (solo en modo WEBGL)"],
      "returns": "该 p5 物件"
    },
    "deviceOrientation": {
      "description": "La variable de sistema deviceOrientation siempre contiene la orientación del dispositivo. El valor de esta variable será o landscape (paisaje) o portrait (retrato). Si la información no está disponible, su valor será undefined.",
      "returns": "该 p5 物件"
    },
    "accelerationX": {
      "description": "La variable de sistema accelerationX siempré contiene la aceleración del dispositivo en el eje X. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "该 p5 物件"
    },
    "accelerationY": {
      "description": "La variable de sistema accelerationX siempré contiene la aceleración del dispositivo en el eje Y. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "该 p5 物件"
    },
    "accelerationZ": {
      "description": "La variable de sistema accelerationX siempré contiene la aceleración del dispositivo en el eje Z. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "该 p5 物件"
    },
    "pAccelerationX": {
      "description": "La variable de sistema pAccelerationX siempré contiene la aceleración del dispositivo en el eje X, del cuadro anterior al cuadro actual. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "该 p5 物件"
    },
    "pAccelerationY": {
      "description": "La variable de sistema pAccelerationY siempré contiene la aceleración del dispositivo en el eje Y, del cuadro anterior al cuadro actual. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "该 p5 物件"
    },
    "pAccelerationZ": {
      "description": "La variable de sistema pAccelerationZ siempré contiene la aceleración del dispositivo en el eje Z, del cuadro anterior al cuadro actual. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "该 p5 物件"
    },
    "rotationX": {
      "description": "La variable de sistema rotationX siempre contiene la rotación del dispositivo en el eje x. El valor está representado entre 0 y  +/-180 grados. Nota: el orden en que las rotaciones son llamadas es importante, por ejemplo, si se usan juntas, deben ser llamadas en el orden Z-X-Y, en caso contrario podría haber un comportamiento errado.",
      "returns": "该 p5 物件"
    },
    "rotationY": {
      "description": "La variable de sistema rotationX siempre contiene la rotación del dispositivo en el eje x. El valor está representado entre 0 y  +/-180 grados. Nota: el orden en que las rotaciones son llamadas es importante, por ejemplo, si se usan juntas, deben ser llamadas en el orden Z-X-Y, en caso contrario podría haber un comportamiento errado.",
      "returns": "该 p5 物件"
    },
    "rotationZ": {
      "description": "La variable de sistema rotationX siempre contiene la rotación del dispositivo en el eje y. El valor está representado entre 0 y  360 grados. A diferencia de rotationX y rotationY, esta variable está solo disponible en dispositivos equipados con una brújula interna. Nota: el orden en que las rotaciones son llamadas es importante, por ejemplo, si se usan juntas, deben ser llamadas en el orden Z-X-Y, en caso contrario podría haber un comportamiento errado.",
      "returns": "该 p5 物件"
    },
    "pRotationX": {
      "description": "La variable de sistema pRotationX siempre contiene la rotación del dispositivo en el eje x, en el cuadro anterior al actual. El valor está representado entre 0 y  +/-180 grados. pRotationX puede ser usado en conjunto con rotationX para determinar la dirección de rotación del dispositivo a lo largo del eje x.",
      "returns": "该 p5 物件"
    },
    "pRotationY": {
      "description": "La variable de sistema pRotationY siempre contiene la rotación del dispositivo en el eje x, en el cuadro anterior al actual. El valor está representado entre 0 y  +/-90 grados. pRotationY puede ser usado en conjunto con rotationY para determinar la dirección de rotación del dispositivo a lo largo del eje y.",
      "returns": "该 p5 物件"
    },
    "pRotationZ": {
      "description": "La variable de sistema pRotationZ siempre contiene la rotación del dispositivo en el eje z, en el cuadro anterior al actual. El valor está representado entre 0 y 359 grados. pRotationZ puede ser usado en conjunto con rotationZ para determinar la dirección de rotación del dispositivo a lo largo del eje z.",
      "returns": "该 p5 物件"
    },
    "setMoveThreshold": {
      "description": "La función setMoveThreshold() es usada para definir el umbral para detectar movimiento de la función deviceMoved(). El valor umbral por defecto es 0.5",
      "params": ["Número: el valor umbral"],
      "returns": "该 p5 物件"
    },
    "setShakeThreshold": {
      "description": "La función setShakeThreshold() es usada para definir el umbral para detectar agitamiento de la función deviceShaken(). El valor umbral por defecto es 30.",
      "params": ["Número: el valor umbral"],
      "returns": "该 p5 物件"
    },
    "deviceMoved": {
      "description": "La función deviceMoved() es llamada cuando el dispositivo es movido en una cantidad mayor al valor umbral en el eje X, Y o Z. El valor umbral por defecto es 0.5",
      "returns": "该 p5 物件"
    },
    "deviceTurned": {
      "description": "La función deviceTurned() es llamada cuando el dispositivo es girado en más de 90 grados de modo continuo. El eje que gatilla la función deviceTurned() es almacenado en la variable turnAxis. El método deviceTurned() puede ser restringido para gatillar en cualquier eje: X, Y o Z, comparando la variable turnAxis con X, Y o Z.",
      "returns": "该 p5 物件"
    },
    "deviceShaken": {
      "description": "La función deviceShaken() es llamada cuando la aceleración total de los cambios de accelerationX y accelerationY son mayores al valor umbral. El valor umbral por defecto es 30",
      "returns": "该 p5 物件"
    },
    "keyIsPressed": {
      "description": "La variable boolean de sistema keyIsPressed es verdadera (true) cuando cualquier tecla es presionada y falsa (false) si no hay ninguna tecla presionada",
      "returns": "该 p5 物件"
    },
    "key": {
      "description": "La variable de sistema key siempre contiene el valor más reciente de la tecla del teclado presionada. Para tener los mejores resultados, es mejor usarla dentro de la función keyTyped(). Para teclas sin valor ASCII, usa la variable keyCode ",
      "returns": "该 p5 物件"
    },
    "keyCode": {
      "description": "La variable keyCode es usada para detectar teclas especiales, como BACKSPACE, DELETE, ENTER, RETURN, ESCAPE, SHIFT, CONTROL, OPTION, ALT, UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW. También puedes revisar las teclas especiales buscando el código keyCode de cualquier tecla en internet.",
      "returns": "该 p5 物件"
    },
    "keyPressed": {
      "description": "La función keyPressed() es llamada una vez cada vez que una tecla es presionada. El código keyCode de la tecla presionada es almacenado en la variable keyCode. Para las teclas sin valor ASCII, usa la variable keyCode.  Puedes comprobar si la variable keyCode es igual a BACKSPACE, DELETE, ENTER, RETURN, ESCAPE, SHIFT, CONTROL, OPTION, ALT, UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW. Para las teclas con valor ASCII que son presionadas, el valor es almacenado en la variable key. Sin embargo, no distingue entre letras mayúsculas y minúsculas. Por esta razón, es recomendable usar la función keyTyped() para leer la variable key, que sí distingue entre mayúsculas y minúsculas. Por la forma en que los sistemas operativos manejan la repetición de teclas, mantener presionada una tecla puede causar múltiples llamadas a keyTyped() (y también keyReleased()). La tasa de repetición es definida por el sistema operativo y según cómo cada computador está configurado. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por teclas. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "该 p5 物件"
    },
    "keyReleased": {
      "description": "La función keyReleased() es llamada una vez cada vez que una tecla es soltada. Ver key y keyCode para más información. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por teclas. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "该 p5 物件"
    },
    "keyTyped": {
      "description": "la función keyTyped es llamada cava vez que una tecla es presionada, excepto cuando son presionadas la steclas de acción como Ctrl, Shift y Alt, que son ignoradas. La tecla presionada más reciente será almacenada en la variable key. Por la forma en que los sistemas operativos manejan la repetición de teclas, mantener presionada una tecla puede causar múltiples llamadas a keyTyped() (y también keyReleased()). La tasa de repetición es definida por el sistema operativo y según cómo cada computador está configurado. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por teclas. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "params": ["Número: el valor umbral"],
      "returns": "该 p5 物件"
    },
    "keyIsDown": {
      "description": "La función keyIsDown() comprueba si la tecla está presionada. Puede ser usada si tienes un objeto que se mueve, y quieres que varias teclas sean capaces de afectar este comportamiento de manera simultánea, como cuando mueves una imagen de forma diagonal. Puedes ingresar cualquier número representando el código de tecla keyCode de la tecla, o usar cualquier de los nombres de la variable keyCode.",
      "params": ["Número: la tecla a buscar"],
      "returns": "该 p5 物件"
    },
    "mouseX": {
      "description": "La variable de sistema mouseX siempre contiene la posición horizontal actual del ratón, relativa al origen (0, 0) del lienzo.",
      "returns": "该 p5 物件"
    },
    "mouseY": {
      "description": "La variable de sistema mouseY siempre contiene la posición vertical actual del ratón, relativa al origen (0, 0) del lienzo.",
      "returns": "该 p5 物件"
    },
    "pmouseX": {
        "description": "La variable de sistema pmouseX siempre contiene la posición horizontal actual del ratón, en el cuadro anterior al actual, relativa al origen (0, 0) del lienzo.",
        "returns": "该 p5 物件"
    },
    "pmouseY": {
      "description": "La variable de sistema pmouseY siempre contiene la posición vertical actual del ratón, en el cuadro anterior al actual, relativa al origen (0, 0) del lienzo.",
      "returns": "该 p5 物件"
    },
    "winMouseX": {
      "description": "La variable de sistema winMouseX siempre contiene la posición horizontal actual del ratón, relativa al origen (0, 0) de la ventana del navegador.",
      "returns": "该 p5 物件"
    },
    "winMouseY": {
      "description": "La variable de sistema winMouseY siempre contiene la posición vertical actual del ratón, relativa al origen (0, 0) de la ventana del navegador.",
      "returns": "该 p5 物件"
    },
    "pwinMouseX": {
      "description": "La variable de sistema pwinMouseX siempre contiene la posición horizontal actual del ratón, en el cuadro anterior al actual, relativa al origen (0, 0) de la ventana del navegador.",
      "returns": "该 p5 物件"
    },
    "pwinMouseY": {
      "description": "La variable de sistema pwinMouseY siempre contiene la posición vertical actual del ratón, en el cuadro anterior al actual, relativa al origen (0, 0) de la ventana del navegador.",
      "returns": "该 p5 物件"
    },
    "mouseButton": {
      "description": "P5.js automáticamente rastrea si el botón del ratón está presionado y cuál botón está presionado. El valor de la variable de sistema mouseButton es o LEFT, RIGHT o CENTER dependiendo de cual fue el último botón presionado. Advertencia: diferentes navegadores pueden diferir.",
      "returns": "该 p5 物件"
    },
    "mouseIsPressed": {
      "description": "La variable boolean de sistema mouseIsPressed es verdadera (true) si el ratón está siendo presionado, y falsa (false) en caso contrario.",
      "returns": "该 p5 物件"
    },
    "mouseMoved": {
      "description": "La función mouseMoved() es llamada cada vez que el ratón se mueve y un botón del ratón no está siendo presionado. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "该 p5 物件"
    },
    "mouseDragged": {
      "description": "La función mouseDragged() es llamada cada vez que el ratón se mueve y un botón del ratón está siendo presionado. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "该 p5 物件"
    },
    "mousePressed": {
      "description": "La función mousePressed() es llamada cada vez que un botón del ratón está siendo presionado. La variable mouseButton (ver la referencia) puede ser usada para determinar cual botón está siendo presionado. Si no se define una función mousePressed(), la función touchStarted() será llamada en su reemplazo, si es que está definida. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "该 p5 物件"
    },
    "mouseReleased": {
      "description": "La función mouseReleased() es llamada cada vez que un botón del ratón es soltado. Si no se define una función mouseReleased(), la función touchEnded() será llamada en su reemplazo, si es que está definida. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "该 p5 物件"
    },
    "mouseClicked": {
      "description": "La función mouseClicked() es llamada cada vez que un botón del ratón es presionado y luego soltado. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "该 p5 物件"
    },
    "mouseWheel": {
      "description": "La función mouseWheel() es llamada cada vez que se detecta un evento de rueda de ratón vertical, ya sea gatillado por un ratón o por un touchpad. La propiedad event.delta retorna el monto que el ratón ha avanzado. Estos valores pueden ser positivos o negativos, dependiendo de la dirección de navegación (en OS X con natural scrolling, los signos son invertidos).  Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método. Debido al soporte actual del evento wheel en Safari, la función podría solo funcionar si return false es incluido cuando se usa Safari.",
      "returns": "该 p5 物件"
    },
    "touchX": {
      "description": "La variable de sistema touchX siempre contiene la posición horizontal de un dedo, relativo al origen (0, 0) del lienzo. Esto funciona mejor con interacciones de un dedo a la vez. Para interacciones multi-dedo, usar el arreglo touches[]",
      "returns": "该 p5 物件"
    },
    "touchY": {
      "description": "La variable de sistema touchY siempre contiene la posición vertical de un dedo, relativo al origen (0, 0) del lienzo. Esto funciona mejor con interacciones de un dedo a la vez. Para interacciones multi-dedo, usar el arreglo touches[]",
      "returns": "该 p5 物件"
    },
    "ptouchX": {
      "description": "La variable de sistema ptouchX siempre contiene la posición horizontal de un dedo, relativo al origen (0, 0) del lienzo, en el cuadro anterior al actual. Esto funciona mejor con interacciones de un dedo a la vez. Para interacciones multi-dedo, usar el arreglo touches[]",
      "returns": "该 p5 物件"
    },
    "ptouchY": {
      "description": "La variable de sistema ptouchY siempre contiene la posición vertical de un dedo, relativo al origen (0, 0) del lienzo, en el cuadro anterior al actual. Esto funciona mejor con interacciones de un dedo a la vez. Para interacciones multi-dedo, usar el arreglo touches[]",
      "returns": "该 p5 物件"
    },
    "winTouchX": {
      "description": "La variable de sistema winTouchX siempre contiene la posición horizontal de un dedo, relativo al origen (0, 0) de la ventana.",
      "returns": "该 p5 物件"
    },
    "winTouchY": {
      "description": "La variable de sistema winTouchY siempre contiene la posición vertical de un dedo, relativo al origen (0, 0) de la ventana.",
      "returns": "该 p5 物件"
    },
    "pwinTouchX": {
      "description": "La variable de sistema pwinTouchX siempre contiene la posición horizontal de un dedo, relativo al origen (0, 0) de la ventana, en el cuadro anterior al actual.",
      "returns": "该 p5 物件"
    },
    "pwinTouchY": {
      "description": "La variable de sistema pwinTouchY siempre contiene la posición verticañ de un dedo, relativo al origen (0, 0) de la ventana, en el cuadro anterior al actual.",
      "returns": "该 p5 物件"
    },
    "touches[]": {
      "description": "La variable de sistema touches[] contiene un arreglo de las posiciones de todos los puntos de toque actuales, relativos al origen (0, 0) del lienzo, y también identificadores para cada toque mientras se mueve. Cada elemento en el arreglo es un objeto con las propiedas x, y e identidad.",
      "returns": "该 p5 物件"
    },
    "touchIsDown": {
      "description": "La variable boolean de sistema touchIsDown es verdadera (true) si en la pantalla hay un toque y falsa (false) si no.",
      "returns": "该 p5 物件"
    },
    "touchStarted": {
      "description": "La función touchStarted() es llamada una vez, cada vez que un toque nuevo es registrado. Si la función touchStarted() no ha sido definida, la función mouseIsPressed() será llamada en su lugar, si es que está definida. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por toque. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "该 p5 物件"
    },
    "touchMoved": {
      "description": "La función touchStarted() es llamada una vez, cada vez que es registrado el movimiento de un toque. Si la función touchMoved() no ha sido definida, la función mouseDragged() será llamada en su lugar, si es que está definida. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por toque. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "该 p5 物件"
    },
    "touchEnded": {
      "description": "La función touchEnded() es llamada una vez, cada vez que un toque finaliza. Si la función touchEnded() no ha sido definida, la función mouseReleased() será llamada en su lugar, si es que está definida. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por toque. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "该 p5 物件"
    },
    "createImage": {
      "description": "Crea una nueva p5.Image (el tipo de datos para almacenar imágenes). Esto provee un nuevo buffer de pixeles para jugar. Define el tamaño del buffer con los parámetros de ancho y altuar. .pixels da acceso a un arreglo conteniendo los valores de todos los pixeles en la ventana mostrada. Estos valores son números. Este arreglo es del tamaño (incluyendo un factor apropiado de pixelDensity) de la ventana mostrada x4, representando los valroes R, G, B, A en orden para cada pixel., moviendo de izquierda a derecha en cada fila, y luego bajando de columna. Ver .pixels para mayor información. Podría ser más simple usar set() y get(). Antes de acceder a los pixeles de una imagen, los datos deben ser cargados con la función loadPixels(). Después de que el arreglo de datos ha sido modificado, la función updatePixels() debe ejecutarse para actualizar los cambios.",
      "params": ["Entero: ancho en pixeles",
      "Entero: altura en pixeles"],
      "returns": "该 p5 物件"
    },
    "saveCanvas": {
      "description": "Graba el lienzo actual como una imagen. En Safari, esto abrirá la imagen en la ventana y el usuario deberá proveer su propio nombre de archivo. Otros navegadores o grabarán el archivo de inmediato, o abrirán una ventana de diálogo.",
      "params": ["Canvas seleccionado: una variable representando un canvas HTML5 específico (opcional)",
      "String",
      "String: jpg o png"],
      "returns": "该 p5 物件"
    },
    "saveFrames": {
      "description": "Captura una secuencia de cuadros que pueden ser usados para crear una película. Acepta una función callback. Por ejemplo, puedes querer mandar los cuadros a un servidor donde pueden ser almacenados o convertidos en una película. Si no se provee una función callback, el navegador abrirá varios diálogos tratando de descargar todas las imágenes que han sido creadas. Con una función callback provista, los datos de imagen no son grabados por defecto, sino que son pasados como argumento a la función callback como un arreglo de objetos, con el tamaño del arreglo siendo igual al número total de cuadros.",
      "params": ["String: ",
      "String: jpg o png",
      "Número: duración en segundos para grabar los cuadros",
      "Número: tasa de cuadros por segundo a grabar",
      "Función: una función callback que será ejecutada para manejar los datos de imagen. Esta función deberá aceptar un arreglo como argumento. El arreglo contendrá el número especificado de cuadros como objetos. Cada objeto tiene tres propiedades: datos de imagen imageData, nombre del archivo y extensión"],
      "returns": "该 p5 物件"
    },
    "loadImage": {
      "description": "Carga una imagen desde una ruta de archivo y crea un objeto p5.Image. La imagen puede no estar inmediatamente disponible para render. Si quieres asegurarte que esté lista antes de hacer algo con ella, ubica la función loadImage() dentro de preload(). También puedes proveer una función callback para manejar la imagen cuando esté lista. La ruta a la imagen debe ser relativa al archivo HTML de tu bosquejo. Cargar desde una URL u otra ubicación remota podría estar bloqueado por las opciones de seguridad del navegador.",
      "params": ["String: ruta de la imagen a cargar",
      "Función(p5.Image): función a ser llamada una vez que la imagen sea cargada. Le será pasado 该 p5 物件.Image",
      "Función(evento): llamada con el evento error si es que la carga de la imagen falla."],
      "returns": "该 p5 物件"
    },
    "image": {
      "description": "Dibuja una imagen en el lienzo principal del bosquejo p5.js.",
      "params": ["p5.Image: la imagen a mostrar",
      "Número: la coordenada x donde se ubicará la esquina superior de la imagen",
      "Número: la coordenada y donde se ubicará la esquina superior de la imagen",
      "Número: ancho de la imagen a dibujar",
      "Número: altura de la imagen a dibujar",
      "Número: la coordenada x en el lienzo de destino donde se ubicará la esquina superior izquierda de la imagen",
      "Número: la coordenada y en el lienzo de destino donde se ubicará la esquina superior izquierda de la imagen",
      "Número: ancho de la imagen a dibujar en el lienzo de destino",
      "Número: altura de la imagen a dibujar en el lienzo de destino",
      "Número: la coordenada x de la esquina superior izquierda del subrectángulo de la imagen original a dibujar en el lienzo de destino",
      "Número: la coordenada y de la esquina superior izquierda del subrectángulo de la imagen original a dibujar en el lienzo de destino",
      "Número: el ancho del subrectángulo de la imagen original a dibujar en el lienzo de destino",
      "Número: la altura del subrectángulo de la imagen original a dibujar en el lienzo de destino"],
      "returns": "该 p5 物件"
    },
    "tint": {
      "description": "Define el valor de relleno para mostrar imágenes. Las imágenes pueden ser teñidas en colores específicos o hacerse transparentes al incluir un valor alpha. Para aplicar transparencia a una imagen sin afectar su color, usa blanco como color de teñido y especifica un valor alpha. Por ejemplo, tint(255, 128) hará una imagen 50% transparente (asumiendo el rango alpha por defecto entre 0 y 255, el que puede ser modificado con la función colorMode()). El valor del parámetro gris debe ser menor o igual al actual valor máximo según lo especificado por colorMode(). El valor máximo por defecto es 255.",
      "params": ["Número|Arreglo: valor de gris, rojo o tinte (dependiendo del modo de color actual), o un arreglo de colores",
      "Número|Arreglo: valor de verde o saturación (dependiendo del modo de color actual)",
      "Número|Arreglo: valor de azul o brillo (dependiendo del modo de color actual)",
      "Número|Arreglo: opacidad del fondo"],
      "returns": "该 p5 物件"
    },
    "noTint": {
      "description": "Remueve el valor actual de relleno para mostrar imágenes y revierte a mostrar las imágenes con sus colores originales.",
      "returns": "该 p5 物件"
    },
    "imageMode": {
      "description": "Define el modo de imagen. Modifica la ubicación desde la que las imágenes son dibujadas, por medio de cambiar la manera en que los parámetros dados a image() son interpretados. El modo por defecto es imageMode(CORNER), que interpreta los paráemtros segundo y tercero de image() como la posición de la esquina superior izquierda de la imagen. Si se dan dos parámetros adicionales, son usados para definir el ancho y la altura la imagen. imageMode(CORNERS) interpreta los paráemtros segundo y tercero de image() como la ubicación de una esquina, y los parámetros cuarto y quinto como la ubicación de la esquina opuesta. imageMode(CENTER) interpreta los parámetros segundo y tercero de image() como el punto central de la imagen. Si dos parámetros adicionales son especificados, son usados para definir el ancho y la altura de la imagen.",
      "params": ["Constante: puede ser CORNER, CORNERS, o CENTER"],
      "returns": "该 p5 物件"
    },
    "pixels[]": {
      "description": "Arreglo tipo Uint8ClampedArray conteniendo los valores de todos los pixeles en la ventana mostrada. Estos valores son números. Este arreglo es del tamaño (incluyendo el factor apropiado de pixelDensity) de la ventana desplegada x4, representando los valores R, G, B, A por cada pixel, moviéndose de izquierda a derecha en cada fila, bajando una columna a la vez. Los monitores Retina y otros de alta densidad tendrán más pixeles en el arreglo (por un factor de pixelDensity al cuadrado). Por ejemplo, si la imagen es de 100 x 100 pixeles, habrán 40.000 valores. En un monitor retina, habrán 160.000. Los primeros cuatro valores (índices 0 a 4) en el arreglo serán los valores R, G, B, A del pixel en la posición (0, 0). Los siguientes cuatro valores (índices 4 a 7) serán los valores R, G, B, A del pixel en la posición (1, 0). De forma más general, para definir los valores de un pixel en (x, y): TODO. Aunque el método descrito es complejo, es lo suficientemente flexible como para trabajar con cualquier densidad de pixeles. Notar que set() inmediatamente se hace cargo de definir los valores apropiados en el arreglo pixels[] para un (x, y) dado a cualquier densidad de pixeles, pero el desempeño puede ser no tan rápido cuando muchas modificaciones son hechas en el arreglo de pixeles. Antes de acceder a este arreglo, los datos deben ser cargados con la función loadPixels(). Después de que el arreglo de datos ha sido modificado, la función updatePixels() debe ser ejecutada para refrescar los cambios. Notar que este no es un arreglo standard de Javascript. Esto significa que las funciones Javascript como slice() o arrayCopy() no funcionan.",
      "returns": "该 p5 物件"
    },
    "blend": {
      "description": "Copia una región de pixeles de una imagen a otra, usando un modo específico de mezcla para hacer la operación. Los modos disponibles de mezcla son: BLEND | DARKEST | LIGHTEST | DIFFERENCE | MULTIPLY| EXCLUSION | SCREEN | REPLACE | OVERLAY | HARD_LIGHT | SOFT_LIGHT | DODGE | BURN | ADD | NORMAL",
      "params": ["p5.Image: imagen fuente",
      "Entero: coordenada x de la esquina superior izquierda de la fuente",
      "Entero: coordenada y de la esquina superior izquierda de la fuente",
      "Entero: ancho de la imagen fuente",
      "Entero: altura de la imagen fuente",
      "Entero: coordenada x de la esquina superior izquierda del destino",
      "Entero: coordenada y de la esquina superior izquierda del destino",
      "Entero: ancho de la imagen destino",
      "Entero: altura de la imagen destino",
      "Constante: el modo de mezcla"],
      "returns": "该 p5 物件"
    },
    "copy": {
      "description": "Copia una región del lienzo a otra región del lienzo desde una imagen usada como el parámetro srcImage en el lienzo. Si la fuente y el destino no son del mismo tamaño, automáticamente redimensionará los pixeles de la fuente para calzar con la región especificada como destino.",
      "params": ["p5.Image: imagen fuente",
      "Entero: coordenada x de la esquina superior izquierda de la fuente",
      "Entero: coordenada y de la esquina superior izquierda de la fuente",
      "Entero: ancho de la imagen fuente",
      "Entero: altura de la imagen fuente",
      "Entero: coordenada x de la esquina superior izquierda de destino",
      "Entero: coordenada y de la esquina superior izquierda de destino",
      "Entero: ancho de la imagen de destino",
      "Entero: altura de la imagen de destino"],
      "returns": "该 p5 物件"
    },
    "filter": {
        "description": "Aplica un filtro al lienzo. Las opciones posibles son: THRESHOLD, que convierte la imagen a pixeles blancos y negros dependiendo de si están arriba o abajo del umbral definido por el parámetro. El parámetro debe estar entre 0.0 (negro) y 1.0 (blanco). Si no se especifica ningún valor, el valor por defecto es 0.5. GRAY, convierte cualquier color en la imagen a un equivalente en la escala de grises, no tiene parámetros. OPAQUE, hace que el canal alpha sea totalmente opaco, no tiene parámetros. INVERT, hace que cada pixel tenga su valor inverso, no tiene parámetros. POSTERIZE, limita cada canal de la imagen a un número de colores especificado como parámetro. El parámetro puede definir entre 2 y 255 valores, pero los resultados más notorios se dan con valores bajos. BLUR, hace que la imagen sea borrosa con un proceso Gaussiano, siendo el parámetro el nivel de cuán borroso es el resultado, si no se usa ningún parámetro, el parámetro por defecto es 1, a mayores valores es más borroso el resultado. ERODE, reduce las áreas claras, no tiene parámetros. DILATE, aumenta las áreas claras, no tiene parámetros.",
        "params": ["Constante: ",
        "Número: un parámetro opcional único a cada filtro, ver más arriba"],
        "returns": "该 p5 物件"
    },
    "get": {
      "description": "Retorna un arreglo de valores RGBA por cada pixel o toma una sección de una imagen. Si no especifican parámetros, se retorna la imagen entera. Usa los parámetros x e y para obtener el valor de un pixel. Toma una sección de la ventana mostrada si especificas los parámetros adicionales w y h. Cuando se obtiene una imagen, los parámetros x e y definen las coordenadas de la esquina superior izquierda de la imagen, sin importar el actual mode imagen definido por imageMode(). Si el pixel solicitado está fuera de la imagen, se retorna el valor [0, 0, 0, 255]. Para obtener los números escalados según los rangoes de color actuales y tomar en cuenta el modo de color según colorMode(), usa getColor() en vez de get(). Tomar el valor de un pixel con get(x, y) es fácil, pero no tan rápido como tomar los datos directamente desde pixels[]. La instrucción equivalente a get(x, y) usando pixels[] con densidad de pixeles d es  var off = (y width + x) d * 4; [pixels[off], pixels[off+1], pixels[off+2], pixels[off+3]]. Ver la referencia de pixels[] para mayor información.",
      "params": ["Número: coordenada x del pixel",
      "Número: coordenada y del pixel",
      "Número: ancho",
      "Número: altura"],
      "returns": "Arreglo|p5.Image: valores de pixel en la posición (x, y) en formato arreglo RGBAs o p5.Image"
    },
    "loadPixels": {
      "description": "Carga los datos de los pixeles en pantalla al arreglo pixels[]. Esta función siempre debe ser llamada antes de leer o escribir en el arreglo pixels[]",
      "returns": "该 p5 物件"
    },
    "set": {
      "description": "Cambia el color de cualquier pixel, o pone una imagen directamente en la ventana. Los parámetros x e y especifican el pixel a cambiar y c especifica el valor del color. Puede ser un objeto p5.Color o un arreglo de pixeles RGBA. También puede ser un valor único en escala de grises. Cuando se define una imagen, los parámetros x e y definen las coordenadas de la esquina superior izquierda de la imagen, sin importar el modo actual de imagen según imageMode(). Después de usar set(), debes llamar a updatePixels()' para que tus cambios aparezcan. Esta función debería ser llamada una vez que todos los pixeles han sido definidos. Definir el color de un solo pixel con set(x, y) es fácil, pero es tan rápido como poner los datos directamente en el arreglo pixels[]. Definir los valores de pixels[] directamente puede ser complicado cuando se trabaja con un monitor retina, pero tendrá un mejor desempeño cuando muchos pixeles necesiten ser definidos directamente en cada iteración. Ver la referencia de pixels[] para mayor información.",
      "params": ["Número: coordenada x del pixel",
      "Número: coordenada x del pixel",
      "Número: coordenada y del pixel",
      "Número|Arreglo|物件：inserta un valor en escala de grises | un arreglo de pixeles | un objeto p5.Color | un objeto p5.Image a copiar"],
      "returns": "该 p5 物件"
    },
    "updatePixels": {
      "example": "",

      "description": "Actualiza la ventana mostrada con los datos del arreglo pixels[]. Se usa en conjunto con loadPixels(). Si solo estás leyendo pixeles desde el arreglo, no hay necesidad de llamar a updatePixels() - actualizar es solo necesario para aplicar cambios. updatePixels() debe ser llamada cada vez que el arreglo de pixeles es manipulado o si se llama a la función set().",
      "params": ["Número: coordenada x de la esquina superior izquierda de la región a actualizar",
      "Número: coordenada y de la esquina superior izquierda de la región a actualizar",
      "Número: ancho de la región a actualizar",
      "Número: altura de la región a actualizar"],
      "returns": "该 p5 物件"
    },
    "loadFont": {
      "description": "Carga un archivo de fuente de letra (.otf, .ttf) desde un archivo o URL, y retorna un objeto PFont. Este método es asíncrono, lo que significa que puede que no finalice antes de que la siguiente línea en tu bosquejo sea ejecutada. La ubicación del archivo debe ser relativo al archivo HTML que lo vincula con tu bosquejo. Cargar desde una URL u otra ubicación remota puede ser bloqueado por las opciones de seguridad del navegador.",
      "params": ["String: número del archivo o URL a cargar",
      "Función: función a ser ejecutada después de que loadFont() es completada"],
      "returns": "物件：objeto p5.Font"
    },
    "loadJSON": {
      "description": "Carga un archivo JSON desde un archivo o una URL, y retorna un objeto o un arreglo. Este método es asíncrono, lo que significa que puede que no termine antes que se ejecute la siguiente línea en tu bosquejo.",
      "params": ["String: nombre de archivo o URL a cargar",
      "Función: función a ser ejecutada después de que loadJSON() finalice, los datos son pasados como primer argumento",
      "Función: función a ser ejecutada si es que hay un error, la respuesta es pasada como primer argumento",
      "String: json o jsonp"],
      "returns": "Objeto|Arreglo: datos JSON"
    },
    "loadStrings": {
      "description": "Lee los contenidos de un archivo y crea un arreglo de Strings de sus líneas individuales. Si el nombre del archivo es usado como parámetro, como en el ejemplo anterior, el archivo debe estar ubicado en el directorio del bosquejo. Alternativamente, el archivo puede ser cargado desde cualquier lugar del computador local usando una dirección absoluta (empieza con / en Unix y Linux, o una letra representando el disco en Windows), o el parámetro de nombre de archivo puede ser una URL donde esté el archivo dentro de una red. Este método es asíncrono, lo que significa que puede ser que su ejecución no termine antes de que se ejecute la siguiente línea del bosquejo.",
      "params": ["String: nombre de archivo o URL a cargar",
      "Función: función a ser ejecutada después de que loadStrings() finalice, el arreglo es pasado como primer argumento",
      "Función: función a ser ejecutada si es que hay un error, la respuesta es pasada como primer argumento"],
      "returns": "Arreglo: un arreglo de Strings"
    },
    "loadTable": {
      "description": "Lee los contenidos de un archivo o URL y crea un objeto p5.Table con sus valores. Si un archivo es especificado, debe ser ubicado en el directorio data del bosquejo. El parámetro de nombre de archivo puede también ser una URL de un archivo en línea. Por defecto, se asume que el archivo está separado por comas (formato CSV), La tabla sólo busca una fila de encabezado si es que se incluye la opción header. Las opciones posibles incluyen: csv: se procesan los datos como valores separados por comas, tsv: se procesan los datos como separados por tabulación, header: la tabla tiene una fila de encabezados (títulos). Si se incluyenn múltiples opciones, se deben ingresar como parámetros separados por comas. Todos los archivos son cargados y grabados usando codificación UTF-8. Este método es asíncrono, lo que significa que su ejecución puede no haber terminado antes de que se ejecute la siguiente línea del bosquejo. Si se llama a loadTable() dentro de preload() se garantiza que se complete la operación antes de que setup() y draw() sean llamadas. Fuera de preload(), puedes suplir una función callback para manejar el objeto.",
      "params": ["String: nombre de archivo o URL a cargar",
      "String|Strings: header, csv, tsv",
      "Función: función a ser ejecutada después de que loadTable() finalice, el arreglo es pasado como primer argumento. Si es exitosa, el objeto Table es pasado como primer argumento, en caso contrario se pasa el valor boolean false."],
      "returns": "Objeto Table conteniendo los datos"
    },
    "loadXML": {
      "description": "Lee los contenidos de un archivo y crea un objeto XML con sus valores. Si el nombre del archivo es usado como parámetro, el archivo debe estar ubicado en el directorio del bosquejo. Alternativamente, el archivo puede ser cargado desde cualquier lugar del computador local usando una dirección absoluta (que empieza con / en Unix y Linux, o con una letra que simbolice el disco duro en Windows). También se puede usar como parámetro de nombre de archivo una URL para un archivo en una red. Este método es asíncrono, lo que significa que su ejecución puede no estar completa antes de que se ejecute la siguiente línea de código en el bosquejo. Llamar a loadXML() dentro de preload() garantiza que la operación se complete antes de que setup() y draw() sean llamados. Fuera de preload(), puedes suplir una función callBack para manejar el objeto.",
      "params": ["String: nombre de archivo o URL a cargar",
      "Función: función a ser ejecutada después de que loadXML() finalice, el objeto XML es pasado como primer argumento",
      "Función: la función a ser ejecutada si es que hay un error, la respuesta es pasada como primer argumento"],
      "returns": "objeto XML que contiene los datos"
    },
    "httpGet": {
      "description": "Método para ejecutar una solicitud HTTP GET. Si no se especifica el tipo de datos, p5 tratará de adivinar basándose en la URL, usando texto por defecto.",
      "params": ["String: nombre del archivo o URL a cargar",
      "物件：parámetro de datos pasados con la solicitud enviada",
      "String: json, jsonp, xml o text",
      "Función: función a ser ejecutada después de que httpGet() finalice, los datos son pasados como primer argumento",
      "Función: función a ser ejecutada si es que hay un error, la respuesta es pasada como primer argumento"],
      "returns": "该 p5 物件"
    },
    "httpPost": {
      "description": "Método para ejecutar una solicitud HTTP POST. Si no se especifica el tipo de datos, p5 tratará de adivinar basándose en la URL, usando texto por defecto.",
      "params": ["String: nombre del archivo o URL a cargar",
      "物件：parámetro de datos pasados con la solicitud enviada",
      "String: json, jsonp, xml o text",
      "Función: función a ser ejecutada después de que httpPost() finalice, los datos son pasados como primer argumento",
      "Función: función a ser ejecutada si es que hay un error, la respuesta es pasada como primer argumento"],
      "returns": "该 p5 物件"
    },
    "httpDo": {
      "description": "Método para ejecutar una solicitud HTTP. Si no se especifica el tipo de datos, p5 tratará de adivinar basándose en la URL, usando texto por defecto. También puedes pasar un objeto especificando todos los parámetros de la solicitud siguiendo los ejemplos dentro de las llamadas de reqwest()",
      "params": ["String: nombre del archivo o URL a cargar",
      "物件：parámetro de datos pasados con la solicitud enviada",
      "String: json, jsonp, xml o text",
      "Función: función a ser ejecutada después de que httpDo() finalice, los datos son pasados como primer argumento",
      "Función: función a ser ejecutada si es que hay un error, la respuesta es pasada como primer argumento"],
      "returns": "该 p5 物件"
    },
    "save": {
      "description": "Graba una imagen, text, json, csv, wav o html. Hace que la descarga ocurra en el computador cliente. Notar que no es recomendado llamar a save() dentro de draw() si está en bucle, porque la función save() abrirá una ventana de diálogo en cada cuadro. El comportamiento por defecto es grabar el lienzo como una imagen. Puedes opcionalmente especificar un nombre de archivo. Por ejemplo: TODO. Alternativamente, el primer parámetro puede ser un puntero a un lienzo p5.Element, un arreglo de Strings, un arreglo de JSON, un objeto JSON, un p5.Table, un p5.Image, o un p5.SoundFile (requiere p5.sound). El segundo parámetro es el nombre del archivo (incluyendo la extensión). El tercer parámetro es para opciones específicas a este tipo de objeto. Este método grabará un archivo que se austa a los parámetros dados. Por ejemplo: TODO. ",
      "params": ["Objeto|String: si se provee un nombre de archivo, se grabará el lienzo como una imagen con la extensión png o jpg, dependiendo del nombre del archivo. Si se provee un objeto, se grabará dependiendo del objeto y el nombre del archivo (ver los ejemplos anteriores)",
      "String: Si se provee un objeto como el primer parámetro, entonces el segundo parámetro indica el nombre del archivo, y debe incluir la extensión apropiada (ver los ejemplos anteriores).",
      "Boolean|String: opciones adicionales depndiendo del tipo de archivo. Por ejemplo, cuando se graba un archivo JSON, true indica que la salida será optimizada según el tamaño del archivo, en vez de por legibilidad."],
      "returns": "该 p5 物件"
    },
    "saveJSON": {
      "description": "Escribe los contenidos de un arreglo o un objeto JSON a un archivo .json. El proceso de grabación del archivo y su ubicación pueden variar entre navegadores web.",
      "params": ["Arreglo|Objeto:",
      "String: ",
      "Boolean: si es verdadero (true), remueve los saltos de línea del archivo de salida para optimizar el tamaño del archivo, en desmedro de la legibilidad."],
      "returns": "该 p5 物件"
    },
    "saveStrings": {
      "description": "Escribe un arreglo de Strings a un archivo de texto, una línea por String. El proceso de grabación del archivo y su ubicación pueden variar entre navegadores web.",
      "params": ["Arreglo: arreglo de Strings a ser escrito",
      "String: nombre del archivo de salida"],
      "returns": "该 p5 物件"
    },
    "saveTable": {
      "description": "Escribe los contenidos de un objeto Table a un archivo. Por defecto es un archivo de texto con valores separados por coma (csv), pero también puede usar separación por tabulación (tsv), o generar una tabla HTML (html). El proceso de grabación del archivo y su ubicación pueden variar entre navegadores web.",
      "params": ["Table: el objeto Table a ser grabado en un archivo",
      "String: el nombre del archivo en el que Table será grabado",
      "String: puede ser tsv, csv o html."],
      "returns": "该 p5 物件"
    },
    "p5.Table": {
      "description": "Los objetos Table almacenan datos con múltiples filas y columnas, tal como una hoja de cálculo tradicional. Los objetos Table pueden ser generados desde cero, dinámicamente, o usando datos desde un archivo existente.",
      "params": ["Arreglo: un arreglo de objetos p5.TableRow"],
      "returns": "p5.Table: 该 p5 物件.Table generado"
    },
    "p5.TableRow": {
      "description": "Un objeto TableRow representa una única fila de datos, grabados en columnas, de una tabla. Un objeto TableRow contiene tanto un arreglo ordenado, como un objeto JSON desordenado.",
      "params": ["String: opcional, puebla la fila con una serie de valores, separados por el separador",
      "String: por defecto, valores separados por coma (csv)"],
      "returns": "该 p5 物件"
    },
    "day": {
      "description": "p5.js se comunica con el reloj de tu computador. La función day() retorna el día actual como un valor entre 1 y 31.",
      "returns": "Número: el día actual"
    },
    "hour": {
      "description": "p5.js se comunica con el reloj de tu computador. La función hour() retorna la hora actual como un valor entre 0 y 23.",
      "returns": "Número: la hora actual"
    },
    "minute": {
      "description": "p5.js se comunica con el reloj de tu computador. La función minute() retorna el minuto actual como un valor entre 0 y 59.",
      "returns": "Número: el minuto actual"
    },
    "millis": {
      "description": "Retorna el número de milisegundos (milésimas de segundo) desde que el programa empezó a correr. La información es usada a menudo para temporizar eventos y animar secuencias",
      "returns": "Número: el número de milisegundos desde que empezó el programa"
    },
    "month": {
      "description": "p5.js se comunica con el reloj de tu computador. La función month() retorna el mes actual como un valor entre 1 y 12.",
      "returns": "Número: el mes actual"
    },
    "second": {
      "description": "p5.js se comunica con el reloj de tu computador. La función second() retorna el mes actual como un valor entre 0 y 59.",
      "returns": "Número: el segundo actual"
    },
    "year": {
      "description": "p5.js se comunica con el reloj de tu computador. La función year() retorna el año actual como un entero (2014, 2015, 2015, etc).",
      "returns": "Número: el año actual"
    },
    "p5.XML": {
      "description": "XML es una representación de un objeto XML, capaz de procesar código XML. Usa loadXML() para cargar archivos externos XML y crear objetos XML",
      "params": ["String:"],
      "returns": "p5.XML: 该 p5 物件.XML generado"
    },
    "createVector": {
      "description": "Crea un nuevo objeto p5.Vector (el tipo de datos para almacenar vectores). Esto provee un vector de dos o tres dimensiones, específicamente un vector euclideano (también conocido como geométrico). Un vector es una entidad que tiene tanto magnitud como dirección.",
      "params": ["Número: componente x del vector",
      "Número: componente y del vector",
      "Número: componente z del vector"],
      "returns": "该 p5 物件"
    },
    "p5.Vector": {
      "description": "Una clase para describir un vector de dos o tres dimensiones, específicamente un vector euclideano (también conocido como geométrico). Un vector es una entidad que tiene tanto magnitud como dirección. El tipo de datos, sin embargo, graba los componentes del vector (x, y para 2D y x,y,z para 3D). La magnitud y la dirección pueden ser calculados con los métodos mag() y heading(). En muchos de los ejemplos de p5.js, verás que p5.Vector es usado para describir una posición, velocidad o aceleración. Por ejemplo, si consideras un rectángulo moviéndose a lo largo de la pantalla, en cada instante tiene una posición (un vector que apunta desde el origen hasta su ubicación), una velocidad(la tasa a la que la posición del objeto cambia por unidad de tiempo, expresada como vector), y aceleración (la tasa a la que la velocidad del objeto cambia por unidad de tiempo, expresada como vector). Como los vectores representan grupos de valores, no podemos simplemente usar las operaciones tradicionales de adición, multiplicación, etc. En vez de eso, necesitaremos hacer matemática de vectores, lo que es simplificado con los métodos dentro de la clase p5.Vector.",
      "params": ["Número: componente x del vector",
      "Número: componente y del vector",
      "Número: componente z del vector"],
      "returns": "该 p5 物件"
    },
    "abs": {
      "description": "Calcula el valor absoluto (magnitud) de un número. Usa Math.abs(). El valor absoluto de un número es siempre positivo.",
      "params": ["Número: número a computar"],
      "returns": "Número: valor absoluto del número dado"
    },
    "ceil": {
      "description": "Calcula el entero más cercano que es mayor o igual que el valor del paráemtro. Usa Math.ceil(). Por ejemplo, ceil(9.03) retorna el valor 10.",
      "params": ["Número: número a redondear"],
      "returns": "Número: número redondeado hacia arriba"
    },
    "constrain": {
      "description": "Restringe un valor a estar entre un valor mínimo y uno máximo.",
      "params": ["Número: número a restringir",
      "Número: límite mínimo",
      "Número: límite máximo"],
      "returns": "Número: número restringido"
    },
    "dist": {
      "description": "Calcula la distancia entre dos puntos",
      "params": ["Número: la coordenada x del primer punto",
      "Número: la coordenada y del primer punto",
      "Número: la coordenada z del primer punto",
      "Número: la coordenada x del segundo punto",
      "Número: la coordenada y del segundo punto",
      "Número: la coordenada z del segundo punto"],
      "returns": "Número: distancia entre los dos puntos"
    },
    "exp": {
      "description": "Retorna el número de Euler (2.71828...) elevado al parámetro n. Usa Math.exp().",
      "params": ["Número: exponente a elevar"],
      "returns": "e^n"
    },
    "floor": {
      "description": "Calcula el valor entero más cercano que es menor o igual al parámetro. Usa Math.floor().",
      "params": ["Número: número a ser redondeado hacia abajo"],
      "returns": "Número: número redondeado hacia abajo"
    },
    "lerp": {
      "description": "Calcula un número entre dos números a un incremento específico. El parámetro amt es la cantidad a interpolar entre los dos valores donde 0.0 es igual al primer punto, 0.1 está muy cerca del primer punto, 0.5 está a medio camino entre ambos números, etc. La función lerp es conveniente para crear movimiento a lo largo de un camino recto y para dibujar líneas punteadas.",
      "params": ["Número: primer valor",
      "Número: segundo valor",
      "Número: número entre 0.0 y 1.0"],
      "returns": "Número: valor interpolado"
    },
    "log": {
      "description": "Calcula el logaritmo natural (logaritmo con base e) de un número. Esta función espera que el parámetro n sea de un valor más grande que 0.0. Usa Math.log().",
      "params": ["Número: número más grande que 0"],
      "returns": "Número: logaritmo naturla de n"
    },
    "mag": {
      "description": "Calcula la magnitud (o tamaño) de un vector. Un vector es una dirección en el espacio comúnmente usada en gráfica computacional y álgebra lineal. Como no tiene posición de inicio, la magnitud del vector puede ser pensada como la distancia entre la coordenada 0,0 a su valor x,y. Por lo tanto, mag() es un atajo a escribir dist(0, 0, x, y).",
      "params": ["Número: primer valor",
      "Número: segundo valor"],
      "returns": "Número: magnitud del vector entre (0, 0) y (a, b)"
    },
    "map": {
      "description": "Escala un nombre de un rango a otro rango. En el primer ejemplo anterior, el número 25 es convertido de un valor en el rango entre 0 y 100 a un valor cuyo rango está entre el borde izquierdo de la ventana (0) y el borde derecho (ancho).",
      "params": ["Número: el valor a ser convertido",
      "Número: límite inferior del rango actual",
      "Número: límite superior del rango actual",
      "Número: límite inferior del rango deseado",
      "Número: límite superior del rango deseado"],
      "returns": "Número: número escalado"
    },
    "max": {
      "description": "Determina el valor más grande en una secuencia de números, y luego retorna ese valor. max() acepta cualquier número de parámetros tipo número, o un arreglo de cualquier largo.",
      "params": ["Número|Arreglo: números a comparar"],
      "returns": "Número: número máximo"
    },
    "min": {
      "description": "Determina el valor más pequeño en una secuencia de números, y luego retorna ese valor. max() acepta cualquier número de parámetros tipo número, o un arreglo de cualquier largo.",
      "params": ["Número|Arreglo: números a comparar"],
    "returns": "Número: número mínimo"
    },
    "norm": {
      "description": "Normaliza un número de un rango a otro rango entre 0 y 1. Es idéntico a map(value, low, high, 0, 1). Los números fuera del rango no son saturados a 0 o 1, porque los números fuera de rango son muchas veces intencionales y útiles (ver el segundo ejemplo más arriba)",
      "params": ["Número: valor entrante a ser normalizado",
      "Número: límite inferior del rango actual",
      "Número: límite superior del rango actual"],
      "returns": "Número: número normalizado"
    },
    "pow": {
      "description": "Facilita las expresiones exponenciales. La función pow() es una manera eficiente de multiplicar números po sí mismos (o sus recíprocos) en grandes cantidades. Por ejemplo, pow(3, 5) es equivalente a la expresión 3*3*3*3*3 y pow (3, -5) es equivalente a 1/3*3*3*3*3. Usa Math.pow().",
      "params": ["Número: base de la expresión exponencial",
      "Número: potencia a la que se eleva la base"],
      "returns": "n^e"
    },
    "round": {
      "description": "Calcula el entero más cercano al parámetro n. Por ejemplo, round(133.8) retorna el valor 134. Usa la función Math.round().",
      "params": ["Número: número a redondear"],
      "returns": "Número: número redondeado"
    },
    "sq": {
      "description": "Eleva al cuadrado un número (lo multiplica por sí mismo), El resultado es siempre un número positivo, porque multiplicar dos números negativos siempre resulta en un número positivo.",
      "params": ["Número: número a elevar al cuadrado"],
      "returns": "Número: número elevado al cuadrado"
    },
    "sqrt": {
      "description": "Calcula la raíz cuadrada de un número. La raíz cuadrada de un número es siempre positiva, aunque puede haber una raíz cuadrada válida que sea negativa. La raíz cuadrada s de un número a es tal que s*s = a. Es lo opuesto a elevar al cuadrado. Usa Math.sqrt().",
      "params": ["Número: número no negativo al que se le calcula la raíz cuadrada"],
      "returns": "Número: raíz cuadrada del número"
    },
    "noise": {
      "description": "Retorna el valor del ruido Perlin en las coordenadas específicas. El ruido Perlin es un generador de secuencias aleatorias produciendo una sucesión de números más naturalmente ordenada y armónica, en comparación con la función estándar random(). Fue inventada por Ken Perlin en los 1980s y ha sido usada desde entonces en aplicaciones gráficas para producir texturas procedurales, movimiento natural, figuras, terrenos, etc. La principal diferencia con la función random() es definida en una espacio infinito n-dimensional donde cada par de coordenadas corresponde a un valor fijo semi-aleatorio (fijado solo durante el tiempo de vida del programa; ver la función noiseSeed()). p5.js puede calcular ruido 1D, 2D y 3D, dependiendo del número de coordenadas dado. El valor resultante siempre estará entre 0.0 y 1.0. El valor de ruido puede ser animado moviéndose a través del espacio del ruido como fue demostrado en el ejemplo superior. Las dimensiones segunda y tercera también pueden ser interpretadas como tiempo. El ruido está estructurado de forma similar a una señal de audio, con respecto al uso de la función de las frecuencias. De forma similar al conecpto de armónicas en física, el ruido Perlin es calculado a lo largo de varias octavas que se han sumado para dar forma al resultado final. Otra manera de ajustar el caracter de la secuencia resultante es la escala de las coordenadas de entrada. Como la función trabaja en un espacio infinito, el valor de las coordenadas no importa como tal, solo la distancia entre las coordenadas sucesivas importa (por ejemplo: cuando se usa noise() dentro de un bucle). Como regla general, a menor la diferencia entre coordenadas, más suave es el ruido resultante. Pasos entre 0.005 y 0.03 funcionan mejor para la mayor parte de las aplicaciones, pero esto diferirá dependiendo del uso.",
      "params": ["Número: coordenada x en el espacio del ruido",
      "Número: coordenada y en el espacio del ruido",
      "Número: coordenada z en el espacio del ruido"],
      "returns": "valor de ruido Perlin (entre 0 y 1) en las coordenadas especificadas"
    },
    "noiseDetail": {
      "description": "Ajusta el caracter y nivel de detalle producido por la función de ruido Perlin. Similar al concepto de armónicas en física, el ruido es calculado a lo largo de varias octavas. Las octavas más graves contribuyen de forma más significativa a la señal de salida y como define la intensidad general del ruido, mientras que las octavas más altas crean detalles más finos en la secuencia de ruido. Por defecto, el ruido es calculado a lo largo de 4 octavas, con cada octava contribuyendo exactamente la mitad que su predecesora, partiendo con una intensidad de 50% para la primera octava. Este tamaño de caída puede ser cambiado al añadir un parámetro adicional a la función. Por ejemplo, un factor de caída de 75% significa que cada octava tendrá un 75% de impacto (25% menos) que la octava anterior. Cualquier valor entre 0.0 y 1.0 es válido, sin embargo nota que valores superiores a 0.5 pueden resultar en que noise() retorne valores mayores a 1.0. Al cambiar estos parámetros, la señal creada por noise() puede ser adaptada para calzar con necesidades y características específicas.",
      "params": ["Número: número de octavas a ser usadas por el ruido",
      "Número: factor de caída para cada octava"],
      "returns": "该 p5 物件"
    },
    "noiseSeed": {
      "description": "Define el valor semilla para la función noise(). Por defecto, noise() produce diferentes resultados cada vez que el programa es ejecutado. Defines el parámetro value a una constante para que retorne la misma secuencia de números pseudo-aleatorios cada vez que el programa es ejecutado",
      "params": ["Número: el valor semilla"],
      "returns": "该 p5 物件"
    },
    "acos": {
      "description": "El inverso de la función cos(), retorna el arcocoseno de un valor. Esta función espera valores entre -1 y 1 y los valores retornados están en el rango entre 0 y PI (3.1415927).",
      "params": ["Número: el valor al que se aplica arcocoseno"],
      "returns": "Número: el arcocoseno del valor"
    },
    "asin": {
      "description": "El inverso de la función sin(), retorna el arcoseno de un valor. Esta función espera valores entre -1 y 1 y los valores retornados están en el rango entre -PI/2  y PI/2 .",
      "params": ["Número: el valor al que se aplica arcoseno"],
      "returns": "Número: el arcoseno del valor"
    },
    "atan": {
      "description": "El inverso de la función tan(), retorna el arcotangente de un valor. Esta función espera valores entre -Infinito e Infinito (exclusivo) y los valores retornados están en el rango entre -PI/2  y PI/2 .",
      "params": ["Número: el valor al que se aplica arcotangente"],
      "returns": "Número: el arcotangente del valor"
    },
    "atan2": {
      "description": "Calcula el ángulo (en radianes) desde un punto específico al origen, medido desde el eje x positivo. Los valores retornados son de tipo float entre  -PI/2  y PI/2. La función atan2() es más frecuentemente usada para orientar figuras figuras geométricas según la posición del cursor. Nota: la coordenada y del punto es el primer parámetro, y la coordenada x es el segundo parámetro, debido a la estructura para calcular la tangente.",
      "params": ["Número: coordenada y del punto",
      "Número: coordenada x del punto"],
      "returns": "Número: el arcotangente del punto dado"
    },
    "cos": {
      "description": "calcula el coseno de un ángulo. Esta función toma en cuenta el modo actual de ángulo según angleMode(). Los valores son retornados en el rango entre -1 y 1.",
      "params": ["Número: el ángulo"],
      "returns": "Número: el coseno del ángulo"
    },
    "sin": {
      "description": "calcula el seno de un ángulo. Esta función toma en cuenta el modo actual de ángulo según angleMode(). Los valores son retornados en el rango entre -1 y 1.",
      "params": ["Número: el ángulo"],
      "returns": "Número: el seno del ángulo"
    },
    "tan": {
      "description": "calcula la tangente de un ángulo. Esta función toma en cuenta el modo actual de ángulo según angleMode(). Los valores son retornados en el rango entre -1 y 1.",
      "params": ["Número: el ángulo"],
      "returns": "Número: la tangente del ángulo"
    },
    "degrees": {
      "description": "Convierte una medida en radianes a su correspondiente valor en grados. Radianes y grados son dos maneras de calcular lo mismo. Hay 360 grados en un círculo y 2*PI radianes en un círculo. Por ejemplo, 90 grados equivalen a PI/2 radianes.",
      "params": ["Número: valor en radianes a ser convertido a grados."],
      "returns": "el ángulo convertido"
    },
    "radians": {
      "description": "Convierte una medida en grados a su correspondiente valor en radianes. Radianes y grados son dos maneras de calcular lo mismo. Hay 360 grados en un círculo y 2*PI radianes en un círculo. Por ejemplo, 90 grados equivalen a PI/2 radianes.",
      "params": ["Número: valor en grados a ser convertido a radianes."],
      "returns": "el ángulo convertido"
    },
    "angleMode": {
      "description": "Define el modo actual de p5 para interpretar ángulos. El modo por defecto es en RADIANS (radianes).",
      "params": ["CONSTANTE: puede ser RADIANS (radianes) o DEGREES (grados)"],
      "returns": "该 p5 物件"
    },
    "randomSeed": {
      "description": "Define la semilla para la función random(). Por defecto, la función random() produce diferentes resultados cada vez que el programa es ejecutado. Definir el parámetro semilla como una constante hace que retorne la misma secuencia de números pseudo-aleatorios cada vez que el programa es ejecutado.",
      "params": ["Número: el valor semilla"],
      "returns": "该 p5 物件"
    },
    "random": {
      "description": "Retorna un número aleaotorio de tipo float (punto flotante). Acepta 0, 1 o 2 argumentos. Si no se le da un argumento, retorna un número aleatorio entre 0 y 1 (sin incluir 1). Si se da un argumento y es un número, retorna un número aleatorio entre 0 y hasta (pero sin incluir) el parámetro. Si se da un argumento y es un arreglo, retorna una elemento al azar del arreglo. Si se dan dos argumentos, retorna un número aleatorio entre el primer argumento y hasta (pero sin incluir) el segundo argumento.",
      "params": ["Número: el límite inferior (inclusivo)",
      "Número: el límite superio (exclusivo)",
      "Arreglo: el arreglo del cual se elige"],
      "returns": "Número: el número aleatorio o un elemento aleatorio de un conjunto de opciones"
    },
    "randomGaussian": {
      "description": "Retorna un número aleatorio ajjustado a una distribución Gaussiana o normal. No existe teóricamente un valor mínimo o máximo que la función randomGaussian() pueda retornar. En vez de eso, existe solo una muy baja probabilidad de retornar valores lejos de la media, y una alta probabilidad de retornar números cercanos a la media. Acepta 0, 1 o 2 argumentos. Si no tiene argumentos, retorna una media de 0 y una desviación estándar de 1. Si tiene un argumento, el argumento es la media (y la desviación estándar es 1). Si tiene dos argumentos, el primero es la media y el segundo es la desviación estándar.",
      "params": ["Número: la media",
      "Número: la desviación estándar"],
      "returns": "el número aleatorio"
    },
    "textAlign": {
      "description": "Define el alineamiento actual para dibujar texto. Acepta dos argumentos: horizAlign(LEFT, CENTER o RIGHT) y vertAlign(TOP, BOTTOM, CENTER, o BASELINE). El parámetro horizAlign se refiere al valor x de la función text(), mientras que vel parámetro vertAlign al valor y. Así que si escribes textAlign(LEFT), estás alineando el borde izquierdo de tu texto al valor x dado en la función text(). Si escribes textAlign(RIGHT, TOP), estás alineando el borde derecho de tu texto con el valor x y el borde superior con el valor y del texto.",
      "params": ["Constante: alineamiento horizontal, puede ser LEFT, CENTER o RIGHT",
      "Constante: alineamiento vertical, puede ser TOP, BOTTOM, CENTER o BASELINE"],
      "returns": "该 p5 物件"
    },
    "textLeading": {
      "description": "Define o retorna el espaciado, en pixeles, entre líneas de texto. Esta configuración será usada en todas las llamadas posteriores a la función text().",
      "params": ["Número: el tamaño en pixeles de espaciamiento entre líneas"],
      "returns": "该 p5 物件"
    },
    "textSize": {
      "description": "Define o retorna el tamaño actual de la tipografía. Este tamaño será usado en todas las llamadas posteriores a la función text(). El tamaño de la tipografía es medido en pixeles.",
      "params": ["Número: el tamaño en pixeles de las letras en pixeles"],
      "returns": "该 p5 物件"
    },
    "textStyle": {
      "description": "Define o retorna el estilo actual de la tipografía. Puede ser NORMAL (normal), ITALIC (cursivo) o BOLD (destacado). Notar que puede ser anulado por estilo CSS. Para tipografías que no sean de sistema (opentype, truetype, etc.), usa loadFont().",
      "params": ["Número|Constante: estilo del texto, puede ser NORMAL, ITALIC o BOLD"],
      "returns": "该 p5 物件"
    },
    "textWidth": {
      "description": "Calcula y retorna el ancho de cualquier caracter o string.",
      "params": ["String: el String de caracteres a medir"],
      "returns": "Número"
    },
    "text": {
      "description": "Dibuja texto en la pantalla. Muestra la información especificada en el primer parámetro en la pantalla, en la posición especificada por los parámetros adicionales. Una fuente por defecto será usada a menos que una fuente sea definida por la función textFont() y un tamaño por defecto será usado a menos que se use la función textSize(). Cambia el color del texto con la función fill(). Cambia la apariencia del texto con las funciones stroke() y strokeWeight(). El texto se muestra en relación a la función textAlign(), que da la opción de dibujar a la izuiqerda, derecha y centro de las coordenadas. Los parámetros x2 e y2 definen un área rectangular donde mostrar el texto y solo puede ser usado por los datos tipo String. Cuando estos parámetros son especificados, son interpretados según la configuración de rectMode(). El texto que no cabe completamente dentro del rectángulo especificado no será dibujado en pantalla.",
      "params": ["String: símbolos alfanuméricos a ser mostrados",
      "Número: coordenada x del texto",
      "Número: coordenada y del texto",
      "Número: por defecto, el ancho de la caja contenedora del texto, ver rectMode() para más información",
      "Número: por defecto, la altura de la caja contenedora del texto, ver rectMode() para más información"],
      "returns": "Objeto"
    },
    "textFont": {
      "description": "Define la función actual con la que se dibujará el contenido de la función text()",
      "params": ["Objeto|String: una fuente cargada con loadFont(), o un String representando una tipografía segura de la web (una fuente ampliamente disponible a lo largo de todos los sistemas)."],
      "returns": "Objeto"
    },
    "p5.Font": {
      "description": "Clase base para manipulación de tipografía",
      "params": ["物件：puntero a la instancia p5"],
      "returns": "该 p5 物件"
    },
    "append": {
      "description": "Añade un valor al final de un arreglo. Extiende el largo de un arreglo en una unidad. Usa la función Array.push()",
      "params": ["Arreglo: Arreglo al que se agregará el dato",
      "Cualquiera: a ser añadido al arreglo"],
      "returns": "该 p5 物件"
    },
    "arrayCopy": {
      "description": "Copia el arreglo (o una parte del arreglo) a otro arreglo. El arreglo fuente es copiado al arreglo de destino, empezando por la posición especificada por srcPosition y a la posición especificada por dstPosition. El número de elementos a copiar es determinado por el largo. Notar que al copiar valores se sobreescriben los valores existentes en el arreglo de destino. Para anexar valores en vez de sobreescribirlos, usa la función concat(). La versión simplificada con dos argumentos, arrayCopy(src, dest), copia un arreglo entero a otro del mismo tamaño. Es equivaletne a arrayCopy(src, 0, dst, 0, src.length). Usar esta función es mucho más eficiente para copiar datos de un arreglo que iterar con un bucle for() y copiar cada elemento individualmente. ",
      "params": ["Arreglo: el arreglo fuente",
      "Número: posición inicial en el arreglo fuente",
      "Arreglo: el arreglo de destino",
      "Número: posición inicial del arreglo de destino",
      "Número: númeor de elementos del arreglo a ser copiados"],
      "returns": "该 p5 物件"
    },
    "concat": {
      "description": "Concatena dos arreglos, usa la función Array.concat(). No modifica los arreglos de entrada.",
      "params": ["Arreglo: primer arreglo a concatenar",
      "Arreglo: segundo arreglo a concatenar"],
      "returns": "Arreglo: el arreglo concatenado"
    },
    "reverse": {
      "description": "Invierte el orden un arreglo, usa Array.reverse().",
      "params": ["Arreglo: arreglo a ser invertido"],
      "returns": "该 p5 物件"
    },
    "shorten": {
      "description": "Disminuye un arreglo en un elemento y retorna el arreglo más corto, usa Array.pop().",
      "params": ["Lista: arreglo a acortar"],
      "returns": "Arreglo: el arreglo acortado"
    },
    "shuffle": {
      "description": "Ordena aleatoriamente los elementos de un arreglo. Implementa el algoritmo Fisher Yates.",
      "params": ["Arreglo: Arreglo a ordenar",
      "Boolean: modifica el arreglo"],
      "returns": "Arreglo: retorna el arreglo ordenado"
    },
    "sort": {
      "description": "Ordena un arreglo de números, desde el más pequeño al más grande, o pone un arreglo de palabras en orden alfabético. El arreglo original no es modificado, un nuevo arreglo ordenado es retornado. El parámetro count define el número de elementos a ordenar. Por ejemplo, si hay 12 elementos en un arreglo y count es 5, los primeros 5 elementos del arreglo serán ordenados.",
      "params": ["Arreglo: arreglo a ordenar",
      "Número: número de elementos a ordenar, empezando desde 0"],
      "returns": "该 p5 物件"
    },
    "splice": {
      "description": "Inserta un valor o un arreglo de valores en un arreglo existente El primer parámetro especifica el arreglo inicial a ser modificado, y el segundo parámetro define los datos a insertarse. El tercer parámetro es un índice que especifica la posición del arreglo a partir de la que se insertarán los datos. Recuerda que el índice del arreglo empieza en 0, así que la primera posición es 0, la segunda es 1, etc.",
      "params": ["Arreglo: arreglo a ser modificado",
      "Cualquiera: valor a ser introducido",
      "Número: posición del arreglo donde se inserta el dato"],
      "returns": "该 p5 物件"
    },
    "subset": {
      "description": "Extrae un arreglo de elementos de un arreglo existente. El parámetro list define el arreglo desde el cual los elementos serán copiados, y los parámetros start y count especifican cuáles elementos extraer. Si no especifica count, los elementos serán extraidos desde el principio. Esta función no modifica el arreglo original",
      "params": ["Arreglo: arreglo del cual se extrae",
      "Número: posición de donde empezar a extraer",
      "Número: número de valores a extraer"],
      "returns": "Arreglo: arreglo de elementos extraidos"
    },
    "float": {
      "description": "Convierte un String a su representación de punto flotante. Los contenidos de un String deben parecerse a un número, en otro caso NaN es retornado. Por ejemplo, float('1234.56') evalua a 1234.56, pero float('giraffe') retorna NaN. Cuando un arreglo de valores es pasado, un arreglo de floats del mismo largo es retornado.",
      "params": ["String: string a ser procesado"],
      "returns": "Número: representación en punto flotante de un string"
    },
    "int": {
      "description": "Convierte un boolean, string o float a su representación en número entero. Cuando un arreglo de valores es introducido, entonces un arreglo de enteros de la misma longitud es retornado.",
      "params": ["String|Boolean|Número|Arreglo: valor a procesar"],
      "returns": "Número: valor representado como entero"
    },
    "str": {
      "description": "Convierte un boolean, string, o número a su representación en string. Cuando un arreglo de valores es introducido, entonces un arreglo de strings de la misma longitud es retornado.",
      "params": ["String|Boolean|Número|Arreglo: valor a procesar"],
      "returns": "String: valor representado como string"
    },
    "boolean": {
      "description": "Convierte un número o string a su representación en boolean. Para números, cualquier valor distinto de cero (positivo o ne gativo), evalua a true, mientras que cero evalua a falso. Para un string, el valor true evalua a true, mientras que cualquier otro valor evalua a falso. Cuando un arreglo de números o strings es introducido, entonces un arreglo de booleans de la misma longitud es retornado.",
      "params": ["String|Boolean|Número|Arreglo: valor a procesar"],
      "returns": "Boolean: representación en formato boolean del valor"
    },
    "byte": {
      "description": "Convierte un número, string o boolean a su representación en byte. Un byte puede solo ser un número entero entre -128 y 127, así que cuando un valor fuera de este rango es convertido, se hace wrap a la representación correspondiente en byte. Cuando un arreglo de números, string, o booleans es introducido, entonces un arreglo de bytes de la misma longitud es retornado.",
      "params": ["String|Boolean|Número|Arreglo: valor a procesar"],
      "returns": "Número: representación en formato byte del valor"
    },
    "char": {
      "description": "Convierte un número o string a su representaciómo como un string de un único caracter. Si se provee un parámetro, es primero pasado como entero y luego evaluado como un string de un único caracter. Cuando un arreglo de números o strings es introducido, entonces un arreglo de strings de un único caracter de la misma longitud es retornado.",
      "params": ["String|Número|Arreglo: valor a procesar"],
      "returns": "String: representación en formato string del valor"
    },
    "unchar": {
      "description": "Convierte un string de un único caracter a su correspondiente representación como valor entero. Cuando un arreglo de strings de un caracter es introducido, entonces un arreglo de enteros de la misma longitud es retornado.",
      "params": ["String|Arreglo: valor a procesar"],
      "returns": "Número: representación en formato entero del valor"
    },
    "hex": {
      "description": "Convierte un número a su correspondiente representación como hexadecimal. Si se ingersa un segundo parámetro, es usado para definir el número de caracteres a generar en la notación hexadecimal. Cuando un arreglo es introducido, entonces un arreglo de strings en notación hexadecimal de la misma longitud es retornado.",
      "params": ["Número|Arreglo: valor a procesar"],
      "returns": "String: representación en formato string hexadecimal del valor"
    },
    "unhex": {
      "description": "Convierte una representación en string de un número hexadecimal a su correspondiente representación como valor entero. Cuando un arreglo de strings en notación hexadecimal es introducido, entonces un arreglo de enteros de la misma longitud es retornado.",
      "params": ["String|Arreglo: valor a procesar"],
      "returns": "Número: representación en formato entero del valor hexadecimal"
    },
    "join": {
      "description": "Combina una arreglo de Strings en un String, cada uno separado por los caracteres usados como parámetro separator. Para unir arreglos de enteros o floats, es necesario primero convertirlos a Strings usando las funciones nf() o nfs().",
      "params": ["Arreglo: arreglo de Strings a ser unidos",
      "String: String a ser posicionado entre cada item"],
      "returns": "String: String unificado"
    },
    "match": {
      "description": "Esta función es usada para aplicar una expresión regular a una porción de texto,  y retorna grupos coincidentes (elementos encontrados entre paréntesis) como un arreglo de Strings. Si no existen coincidencias, se retorna el valor null. Si no se especifican grupos en la expresión regular, pero la secuencia coincide, un arreglo de largo 1 (con el texto coincidente como primer elemento del arreglo) será retornado. Para usar la función, primero comprueba si el resultado es null. Si el resultado es null, entonces la secuencia no tuvo coincidencias. Si la secuencia tuvo coincidencias, retorna un arreglo. Si exsiten grupos (especificados como conjuntos de paréntesis) en la expresión regular, entonces los contenidos de cada uno serán retornados en el arreglo. El elemento[0] de una coincidencia de expresión regular retorna el string coincidente, y el grupo de coincidencia empieza en el elemento[1] (el primer grupo es [1], el segundo es [2], etc).",
      "params": ["String: el String a ser buscado",
      "String: la expresión regular a ser usada para buscar coincidencias"],
      "returns": "Arreglo: arreglo de Strings encontrados"
    },
    "matchAll": {
      "description": "Esta función es usada para aplicar una expresión regular a una porción de texto,  y retorna una lista de grupos coincidentes (elementos encontrados entre paréntesis) como un arreglo de Strings bidimensional. Si no existen coincidencias, se retorna el valor null. Si no se especifican grupos en la expresión regular, pero la secuencia coincide, un arreglo de dos dimensiones es retornado, pero es de largo 1. Para usar la función, primero comprueba si el resultado es null. Si el resultado es null, entonces la secuencia no tuvo coincidencias. Si la secuencia tuvo coincidencias, retorna un arreglo 2D. Si exsiten grupos (especificados como conjuntos de paréntesis) en la expresión regular, entonces los contenidos de cada uno serán retornados en el arreglo. El elemento[i][0] de una coincidencia de expresión regular retorna el string coincidente completo, y el grupo de coincidencia empieza en el elemento[i][1] (el primer grupo es [i][1], el segundo es [i][2], etc).",
      "params": ["String: el String a ser buscado",
      "String: la expresión regular a ser usada para buscar coincidencias"],
      "returns": "Arreglo: arreglo 2D de Strings encontrados"
    },
    "nf": {
      "description": "Función de utilidad para formatear números a strings. Existen dos veriones: una para formatear floats, y una para formatear enteros. Los valores de los dígitos y los parámetros left y right siempre deben ser enteros positivos",
      "params": ["Número|Arreglo: el número a formatear",
      "Número: número de dígitos a la izquierda del punto decimal",
      "Número: número de dígitos a la derecha del punto decimal"],
      "returns": "String|Arreglo: String formateada"
    },
    "nfc": {
      "description": "Función de utilidad para formatear números en strings y poner las comas apropiadas para señalar múltiplos de mil. Hay dos versiones: una para números enteros y otra para arreglos de enteros. El valor del parámetro right debe siempre ser un entero positivo.",
      "params": ["Número|Arreglo: el número a formatear",
      "Número: número de dígitos a la derecha del punto decimal"],
      "returns": "String|Arreglo: String formateada"
    },
    "nfp": {
      "description": "Función de utilidad para formatear números en strings. Similar a nf() pero pone un signo + en frente de los números positivos y un signo - en frente de números negativos. Hay dos versiones, una para formatear floats y otra para formatear enteros. Los valores de los parámetros left y right deben siempre ser enteros positivos.",
      "params": ["Número|Arreglo: el número a formatear",
      "Número: número de dígitos a la izquierda del punto decimal",
      "Número: número de dígitos a la derecha del punto decimal"],
      "returns": "String|Arreglo: String formateada"
    },
    "nfs": {
      "description": "Función de utilidad para formatear números en strings. Similar a nf() pero pone un espacio en frente de los números positivos y un signo - en frente de números negativos. Hay dos versiones, una para formatear floats y otra para formatear enteros. Los valores de los parámetros left y right deben siempre ser enteros positivos.",
      "params": ["Número|Arreglo: el número a formatear",
      "Número: número de dígitos a la izquierda del punto decimal",
      "Número: número de dígitos a la derecha del punto decimal"],
      "returns": "String|Arreglo: String formateada"
    },
    "split": {
      "description": "La función split usa String.split(), corta un String en pedazos usando un caracter o String como delimitador. El parámetro delim especifica el caracter o caracteres que marcan los bordes entre cada pieza. Un arreglo String[] es retornado, que contiene cada una de las piezas. La función splitTokens() funciona de forma similar, excepto que divide usango un rango de caracteres en vez de usar un caracter o una secuencia de caracteres específicos.",
      "params": ["String: el String a ser dividido",
      "String: el String usado para separar los datos"],
      "returns": "Arreglo: arreglo de Strings"
    },
    "splitTokens": {
      "description": "La función splitTokens() divide un String en uno o varios caracteres delimitadores o tokens. El parámetro delim especifica el o los caracteres a ser usados como borde. Si no se especifican caracteres delim, cualquier caracter tipo whitespace será usado para dividir. Los caracteres whitespace incluyen tabulación (\t), nueva línea (\n), retorno de carro (\r), entrada de formulario (\f), y espacio.",
      "params": ["String: el String a ser dividido",
      "String: lista de Strings individuales que serán usados como separadores"],
      "returns": "Arreglo: arreglo de Strings"
    },
    "trim": {
      "description": "Remueve caracteres tipo whitespace (espacio en blanco) del comienzo y el final de un String. En adición a los caracteres estámdar de whitespace como espacio, retorno de carro y tabulación, esta función también remueve el caracter Unicode nbsp.",
      "params": ["String|Arreglo: un String o arreglo de Strings a ser recortados."],
      "returns": "String|Arreglo: un String o arreglo de Strings recortados."
    },
    "camera": {
      "description": "Define la posición de la cámara",
      "params": ["Número: valor de la posición de la cámara en el eje x",
      "Número: valor de la posición de la cámara en el eje y",
      "Número: valor de la posición de la cámara en el eje z"],
      "returns": "p5: 该 p5 物件"
    },
    "perspective": {
      "description": "Define la perspectiva de la cámara",
      "params": ["Número: frustum del campo de visión vertical de la cámara, de abajo hacia arriba, en grados",
      "Número: frustum de la relación de aspecto de la cámara",
      "Número: frustum del largo del plano cercano",
      "Número: frustum del largo del plano lejano"],
      "returns": "p5: 该 p5 物件"
    },
    "ortho": {
      "description": "Define la cámara ortogonal",
      "params": ["Número: define el frustum del plano izquierdo de la cámara",
      "Número: define el frustum del plano derecho de la cámara",
      "Número: define el frustum del plano inferior de la cámara",
      "Número: define el frustum del plano superior de la cámara",
      "Número: define el frustum del plano cercano de la cámara",
      "Número: define el frustum del plano lejano de la cámara"],
      "returns": "p5: 该 p5 物件"
    },
    "ambientLight": {
      "description": "Crea una luz ambiente con color",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color actual), o arreglo de color o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad"],
      "returns": "该 p5 物件"
    },

    "directionalLight": {
      "description": "Crea una luz direccional con color y dirección",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color actual), o arreglo de color o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad",
      "Número|p5.Vector: dirección del eje x o un p5.Vector",
      "Número: opcional, dirección del eje y",
      "Número: opcional, dirección del eje z"],
      "returns": "该 p5 物件"
    },
    "pointLight": {
      "description": "Crea una luz puntual con color y posición",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color actual), o arreglo de color o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad",
      "Número|p5.Vector: dirección del eje x o un p5.Vector",
      "Número: opcional, dirección del eje y",
      "Número: opcional, dirección del eje z"],
      "returns": "p5: 该 p5 物件"
    },
    "normalMaterial": {
      "description": "Material normal para geometría. Puedes ver todos los posibles materiales en este ejemplo (TODO).",
      "returns": "p5: 该 p5 物件"
    },
    "texture": {
      "description": "Textura para geometría. Puedes ver todos los posibles materiales en este ejemplo (TODO).",
      "params": ["p5.Image|p5.MediaElement|p5.Graphics: gráfica bidimensional para hacer render como textura."],
      "returns": "p5: 该 p5 物件"
    },
    "ambientMaterial": {
      "description": "Material ambiente para geometría con un color dado. Puedes ver todos los posibles materiales en este ejemplo (TODO).",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color), o arreglo de color, o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad"],
      "returns": "p5: 该 p5 物件"
    },
    "specularMaterial": {
      "description": "Material espejo para geometría con un color dado. Puedes ver todos los posibles materiales en este ejemplo (TODO).",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color), o arreglo de color, o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad"],
      "returns": "p5: 该 p5 物件"
    },
    "p5.RendererGL": {
      "description": "TODO",
      "returns": "p5: 该 p5 物件"
    },
    "p5.Shader": {
      "description": "Clase Shader para el modo WEBGL",
      "params": ["p5.RendererGL: una instancia de p5.RendererGL que servirá de contexto GL para este nuevo p5.Shader",
      "String: código fuente para el vertex shader (en forma de string)",
      "String: código fuente para el fragment shader (en forma de string)"],
      "methods": ["Wrapper de las funciones gl.uniform. Como almacenamos información de uniform en el shader, la podemos usar para revisar los datos provistos y llamar a la función apropiada."]
    }
  },
  "p5.Image": {
    "loadPixels": {
      "description": "blah",
      "params": ["Numero: blah",
                 "Numero: blah"],
      "returns": "TODO"
    }
  },
  "p5.Element": {
    "description": "Clase base para todos los elementos añadidos al bosuqejo, incluyendo lienzo, buffers de gráficas, y otros elementos HTML. Los métodos en azul están incluidos en la funcionalidad base, los métodos en marrón son añadidos con la biblioteca p5.dom. No se ejecutan directamente, pero los objetos p5.Element son creados llamando a las funciones createCanvas(), createGraphics(), o en la biblioteca p5.dom, createDiv, createImg, createInput, etc.",
    "params": ["String: node DOM envolvente.", "物件：puntero a instancia p5."],
    "returns": "TODO"
  }
}
